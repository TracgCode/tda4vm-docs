

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.2. J721E SBL &mdash; Platform Development Kit (PDK) - JACINTO User Guide</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Platform Development Kit (PDK) - JACINTO User Guide" href="../index.html"/>
        <link rel="up" title="5. Bootloader (SBL)" href="../family_cfg/jacinto/index_boot_jacinto.html"/>
        <link rel="next" title="5.3. Boot App" href="boot_app.html"/>
        <link rel="prev" title="5.1. SBL Overview" href="boot.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">
  <header id="tiHeader">
    <div class="top">
      <ul>
        <li id="top_logo">
          <a href="http://www.ti.com">
            <img src="../_static/img/ti_logo.png"/>
          </a>
        </li>
      </ul>
    </div>
    <div class="nav"></div>
  </header>
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index_jacinto.html" class="icon icon-home"> Platform Development Kit (PDK) - JACINTO User Guide
          

          
          </a>

          
            
            
              <div class="version">
                09_00_01
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../family_cfg/jacinto/index_release_notes_jacinto.html">2. Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">3. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../family_cfg/jacinto/index_modules_jacinto.html">4. Modules</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../family_cfg/jacinto/index_boot_jacinto.html">5. Bootloader (SBL)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="boot.html">5.1. SBL Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.2. J721E SBL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">5.2.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-diagram">5.2.2. Block Diagram</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-map">5.2.3. Memory Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#directory-structure">5.2.4. Directory structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#image-formats-1">5.2.5. Image Formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-the-sbl-and-its-components">5.2.6. Building the SBL and its components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pre-requisites-to-building">5.2.6.1. Pre-requisites to Building</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compiling-sbl-for-gp-general-purpose-device">5.2.6.2. Compiling SBL for GP (General Purpose) Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compiling-sbl-for-hs-high-security-device">5.2.6.3. Compiling SBL for HS (High Security) Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compiling-appimage-that-can-be-loaded-by-sbl">5.2.6.4. Compiling appimage that can be loaded by SBL</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#testing-the-sbl">5.2.7. Testing the SBL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boot-modes">5.2.8. Boot Modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#booting-via-sd-card">5.2.8.1. Booting Via SD Card</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booting-via-emmc-uda-partition">5.2.8.2. Booting Via eMMC UDA partition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booting-via-emmc-boot0-partition">5.2.8.3. Booting Via eMMC BOOT0 partition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booting-via-ospi-flash">5.2.8.4. Booting Via OSPI flash</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booting-via-uart">5.2.8.5. Booting via UART</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hsm-boot">5.2.9. HSM Boot</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evm-setup-for-testing-sbl">5.2.10. EVM Setup for testing SBL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-to-guides">5.2.11. How to Guides</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generate-multicore-appimage">5.2.11.1. Generate Multicore Appimage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sign-appimage">5.2.11.2. Sign Appimage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-from-gp-device">5.2.11.3. Boot from GP device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-from-hs-se-device">5.2.11.4. Boot from HS-SE device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-from-hs-fs-device">5.2.11.5. Boot from HS-FS device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-from-ospi">5.2.11.6. Boot from OSPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-from-mmcsd">5.2.11.7. Boot from MMCSD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fall-back-mechanism-if-copy-failed-from-ospi-flash">5.2.11.8. Fall back mechanism if copy failed from OSPI flash</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-from-ospi-nand">5.2.11.9. Boot from OSPI NAND</a></li>
<li class="toctree-l4"><a class="reference internal" href="#secure-hsm-boot-from-ospi-nand-on-hs-se-device">5.2.11.10. Secure HSM Boot from OSPI NAND on HS-SE device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#secure-hsm-boot-from-ospi-nor-on-hs-se-device">5.2.11.11. Secure HSM Boot from OSPI NOR on HS-SE device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#secure-hsm-boot-from-mmcsd-on-hs-se-device">5.2.11.12. Secure HSM Boot from MMCSD on HS-SE device</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="boot_app.html">5.3. Boot App</a></li>
<li class="toctree-l2"><a class="reference internal" href="boot_hlos.html">5.4. Boot HLOS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../family_cfg/jacinto/index_board_jacinto.html">6. Board/EVM Abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../family_cfg/jacinto/index_howto_jacinto.html">7. How to Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../family_cfg/jacinto/index_faq_jacinto.html">8. Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../family_cfg/jacinto/index_developer_notes_jacinto.html">9. Developer Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index_jacinto.html">Platform Development Kit (PDK) - JACINTO User Guide</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index_jacinto.html">Docs</a> &raquo;</li>
      
          <li><a href="../family_cfg/jacinto/index_boot_jacinto.html"><span class="section-number">5. </span>Bootloader (SBL)</a> &raquo;</li>
      
    <li><span class="section-number">5.2. </span>J721E SBL</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="part-default-soc-caps-sbl">
<h1><span class="section-number">5.2. </span>J721E SBL<a class="headerlink" href="#part-default-soc-caps-sbl" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2><span class="section-number">5.2.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Secondary Bootloader (SBL) for J721E initializes the execution
environment for multi-core applications and this can be used to demonstrate
a real world product experience. This section covers additional details
including execution sequence, tools and additional flashing instructions.</p>
<p>The SBL is essentially a baremetal application, and it uses many components
from the Processor SDK</p>
<ul class="simple">
<li><p>&lt;PDK&gt;/packages/ti/build         : For build infrastructure</p></li>
<li><p>&lt;PDK&gt;/packages/ti/csl           : For initialization and SoC addresses</p></li>
<li><p>&lt;PDK&gt;/packages/ti/board         : For board and usecase specific initialization</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/spi       : For reading applications from OSPI flash</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/udma      : For reading data from boot media using DMA</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/mmcsd     : For reading applications from MMC/SD/eMMC</p></li>
<li><p>&lt;PDK&gt;/packages/ti/fs/fatfs      : For reading files from MMC/SD/eMMC</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/sciclient : For communicating with DMSC sub-system</p></li>
<li><p>&lt;PDK&gt;/packages/ti/drv/uart      : For log messages</p></li>
<li><p>&lt;PDK&gt;/packages/ti/osal          : Primitives required by ti/drv components</p></li>
</ul>
<p>The SBL is in turn used by the board framework to load and start diagnostics</p>
<p class="rubric" id="bootloader-execution-sequence">Bootloader Execution Sequence</p>
<ul class="simple">
<li><p><strong>Power On Reset</strong></p></li>
<li><p><strong>ROM Bootloader (RBL)</strong></p>
<ul>
<li><p>Software pre-programmed in Jacinto ROM memory starts executing</p></li>
<li><p>The RBL performs platform configuration and initialization.</p></li>
<li><p>It then checks sysboot pins and chooses booting device</p></li>
<li><p>The RBL then configures PLL and clock settings for R5, and
boot media like eMMC, SD/MMC, OSPI, UART, PCIe, Ethernet etc for reliable
boot.</p></li>
<li><p>If no valid bootloader found on booting device, the RBL checks for next
booting device, based on sysboot pins</p></li>
<li><p>It then gets image size and load address by checking the X.509 certificate that
is part of the bootloader image.</p></li>
<li><p>The RBL then verifies, optionally decrypts and loads the binary to internal
memory at the load address specified in the X.509 certificate.</p></li>
<li><p>Finally it resets the R5 and passes control to Secondary Bootloader(SBL) running on the R5.</p></li>
</ul>
</li>
<li><p><strong>Secondary bootloader(SBL)</strong></p>
<ul>
<li><p>User level secondary bootloader(SBL) begins execution from internal memory.
It enables ATCM, starts PMU timers for profiling, initializes the MCU,
and sets up the stack, heap and globals. It then jumps to main().</p></li>
<li><p>Board Initialization is done by calls to <strong>Board_init()</strong> API.For additional
details refer <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/Board_EVM_Abstration.html">Processor SDK Board Support</a>.</p></li>
<li><p>The RAT is setup. Pin MUX and UART console are setup by calling <strong>Board_init()</strong> API. The
system firmware (SYSFW or TIFS) is then loaded from the boot media into the DMSC subsystem.</p></li>
<li><p>Once the system firmware is up and running, the rest of the initialization can be done.</p></li>
<li><p>This includes optionally using <strong>Board_init()</strong> to configure PLLs, LPSCs and DDR.</p></li>
<li><p>The SBL then loads the application from the boot media. If the image is signed, the
application will be copied into a user specified reserved memory, and the SBL will attempt
to verify the image by calling system firmware APIs. On HS devices, the boot proceeds
only if image verification passes.</p></li>
<li><p>The SBL parses application image(s) for each of the core(s) from boot
media and scatter loads it to memory.</p></li>
<li><p>Once the application is loaded, the SBL communicates with the system firmware
to setup the clocks for the core(s) and release it from reset.</p></li>
<li><p>The core then starts executing from application entry point.</p></li>
</ul>
</li>
<li><p><strong>Variants of SBL</strong></p></li>
</ul>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SBL Configuration</p></th>
<th class="head"><p>Boot Media</p></th>
<th class="head"><p>Boot Type</p></th>
<th class="head"><p>Sample Application</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="4"><p>SBL MMCSD</p></td>
<td rowspan="4"><p>MMCSD</p></td>
<td rowspan="4"><p>Legacy</p></td>
<td><p>Multicore Boot Test</p></td>
<td><p>Boots the target using an SD card containing bootloader,
sysfw and application image</p></td>
</tr>
<tr class="row-odd"><td><p>BootApp RTOS</p></td>
<td><p>Tertiary boot loader which boots main domain cores in
stages from SD card</p></td>
</tr>
<tr class="row-even"><td><p>BootApp Linux</p></td>
<td><p>Tertiary boot loader which boots main domain cores and
Linux Kernel in stages from SD card</p></td>
</tr>
<tr class="row-odd"><td><p>BootApp QNX</p></td>
<td><p>Tertiary boot loader which boots main domain cores and QNX
in stages from SD card</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>SBL OSPI</p></td>
<td rowspan="4"><p>OSPI NOR</p></td>
<td rowspan="4"><p>Legacy</p></td>
<td><p>Multicore Boot Test</p></td>
<td><p>Boots the target using bootloader, sysfw and application
image which are flashed at a particular offset in OSPI NOR</p></td>
</tr>
<tr class="row-odd"><td><p>BootApp RTOS</p></td>
<td><p>Tertiary boot loader which boots main domain cores in
stages from OSPI</p></td>
</tr>
<tr class="row-even"><td><p>BootApp Linux</p></td>
<td><p>Tertiary boot loader which boots main domain cores and
Linux Kernel in stages from OSPI</p></td>
</tr>
<tr class="row-odd"><td><p>BootApp QNX</p></td>
<td><p>Tertiary boot loader which boots main domain cores and
QNX in stages from OSPI</p></td>
</tr>
<tr class="row-even"><td><p>SBL UART</p></td>
<td><p>UART</p></td>
<td><p>Legacy</p></td>
<td><p>Multicore Boot Test</p></td>
<td><p>A Serial connection is used for transferring the bootloader
binary from PC to target board through XMODEM protocol. The
bootloader on execution prompts for application image to
transfer through XMODEM.</p></td>
</tr>
<tr class="row-odd"><td><p>SBL CUST</p></td>
<td><p>CUST</p></td>
<td><p>Legacy</p></td>
<td><p>Multicore Boot Test</p></td>
<td><p>Flavor of OSPI SBL with custom flags. With this SBL, user
can control the following things</p>
<ul class="simple">
<li><p>DDR initialization</p></li>
<li><p>Initialization of PLLs</p></li>
<li><p>Initialization of clocks</p></li>
<li><p>Skipping MCU Reset</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>SBL eMMC Boot0</p></td>
<td><p>eMMC Boot0</p></td>
<td><p>Legacy</p></td>
<td><p>Multicore Boot Test</p></td>
<td><p>Boots the target using bootloader, sysfw and application
images which are flashed to a particular offset to eMMC
Boot0 partition</p></td>
</tr>
<tr class="row-odd"><td><p>SBL eMMC UDA</p></td>
<td><p>eMMC UDA</p></td>
<td><p>Legacy</p></td>
<td><p>Multicore Boot Test</p></td>
<td><p>Boots the target using bootloader, sysfw and application
images which are copied to eMMC UDA partition</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>SBL Boot Perf CUST</p></td>
<td rowspan="2"><p>OSPI NOR</p></td>
<td><p>Legacy</p></td>
<td><p>Boot Perf Test</p></td>
<td><p>Flavor of OSPI SBL with custom flags.</p>
<ul class="simple">
<li><p>Skips DDR initialization</p></li>
<li><p>Uses OCMC RAM as SBL scratch memory</p></li>
<li><p>Intializes only MCU domain to save boot time</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>Legacy</p></td>
<td><p>Early CAN Response</p></td>
<td><p>Flavor of OSPI SBL with custom flags.</p>
<ul class="simple">
<li><p>Skips DDR initialization</p></li>
<li><p>Uses OCMC RAM as SBL scratch memory</p></li>
<li><p>Intializes only MCU domain to save boot time</p></li>
<li><p>User needs to enable SBL_SKIP_PINMUX_ENABLE in
sbl_component.mk to save pim muxing time as well</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>SBL XIP 133/166</p></td>
<td><p>OSPI NOR</p></td>
<td><p>Legacy</p></td>
<td><p>XIP Boot Test</p></td>
<td><p>Different OSPI Configurations</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>SBL MMCSD HLOS</p></td>
<td rowspan="2"><p>MMCSD</p></td>
<td rowspan="2"><p>Legacy</p></td>
<td><p>combined_opt.appimage</p></td>
<td><p>Boots high level OS Linux using an SD card containing
bootloader, sysfw and HLOS application image</p></td>
</tr>
<tr class="row-even"><td><p>combined_dev.appimage</p></td>
<td><p>Boots high level OS U-Boot using an SD card containing
bootloader, sysfw and HLOS application image</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>SBL OSPI HLOS</p></td>
<td rowspan="2"><p>OSPI NOR</p></td>
<td rowspan="2"><p>Legacy</p></td>
<td><p>combined_opt.appimage</p></td>
<td><p>Boots high level OS Linux using bootloader, sysfw and
HLOS application image which are flashed to a particular
offset in OSPI NOR</p></td>
</tr>
<tr class="row-even"><td><p>combined_dev.appimage</p></td>
<td><p>Boots high level OS U-Boot using bootloader, sysfw and
HLOS application image which are flashed to a particular
offset in OSPI NOR</p></td>
</tr>
</tbody>
</table>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>RBL requires boot loader (SBL) to be in a special format with the binary image
appended to a X.509 certificate. The certificate contains the load address, size
and SHA of the bootloader image.</p></li>
<li><p>For a detailed description of ROM bootloader and more information on the image
format expected by the RBL refer the initialization chapter in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruil1">J721E Technical Reference Manual</a></p></li>
<li><p>In addition to the bootloader and application, the DMSC firmware binary is also needed
for the SoC to complete the system boot flow.</p></li>
<li><p>If building the combined ROM boot image, the DMSC firmware binary is part of the bootloader
image itself and is not flashed separately.</p></li>
<li><p>The first 256 bytes of the ATCM are reserved by SBL for its use. The SBL initializes
the ATCM with 0xFF before it uses it.</p></li>
<li><p>If the multicore application image is signed using the TI Dummy Key, instead of a
degenerate key (default setting) the same binary can be used on GP and HS devices.
For information on the application’s X.509 certificate format, please refer
<a class="reference external" href="http://downloads.ti.com/tisci/esd/latest/2_tisci_msgs/security/sec_cert_format.html#security-x509-certificate-documentation">Security X509 Certificate Documentation</a></p></li>
<li><p>When the R5 is released from reset, it will always fetch and execute the first
intruction from address 0x0.</p></li>
</ul>
</div></section>
<section id="block-diagram">
<span id="sbl-high-level-arch"></span><h2><span class="section-number">5.2.2. </span>Block Diagram<a class="headerlink" href="#block-diagram" title="Permalink to this headline">¶</a></h2>
<img alt="../_images/k3_sbl_arch_block_diag.png" src="../_images/k3_sbl_arch_block_diag.png" />
</section>
<section id="memory-map">
<span id="sbl-memory-usage"></span><h2><span class="section-number">5.2.3. </span>Memory Map<a class="headerlink" href="#memory-map" title="Permalink to this headline">¶</a></h2>
<img alt="../_images/k3_sbl_mem_usage.png" src="../_images/k3_sbl_mem_usage.png" />
</section>
<section id="directory-structure">
<span id="sbl-directory-structure"></span><h2><span class="section-number">5.2.4. </span>Directory structure<a class="headerlink" href="#directory-structure" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>sbl
│
├── board
│   └── k3
│       └── sbl_main.c                                        &lt;= define main() for SBL, board specific init
│
├── build
│   ├── makefile                                              &lt;= makefile for the SBL component
│   ├── boot_app.mk                                           &lt;= makefile to build BootApp examples
│   ├── sbl_boot_test.mk                                      &lt;= Builds SBL single core tests
│   ├── sbl_multicore_boot_test.mk                            &lt;= Builds SBL multicore boot test which uses single core tests to create multicore image
│   ├── sbl_smp_test.mk                                       &lt;= Builds example app for using SBL lib
│   ├── sbl_mcu0_boot_perf_test.mk                            &lt;= Builds example app for SBL performance tuning
│   ├── sbl_mcu0_boot_xip_entry.mk                            &lt;= Builds example trampoline app to demonstrate transitioning to a XIP app from SBL
│   ├── sbl_mcu0_boot_xip_test.mk                             &lt;= Builds example app to demonstrate XIP execution from XIP capable boot media
│   ├── sbl_img.mk                                            &lt;= builds SBL image that is loaded and executed by ROM code
│   ├── sbl_lib.mk                                            &lt;= Builds sbl library that other apps can link into
│   └── sbl_multicore_smp.mk                                  &lt;= Builds multi-core image from SBL lib eg. test to demonstrate symmetric multiprocessor boot (SMP)
│
├── example
│   ├── k3MulticoreApp
│   |   ├── binary
│   │   │   └── [soc]
│   │   │       ├── sbl_boot_test_&lt;board_name&gt;_allcoresTestApp_release.appimage                         &lt;= SBL loadable board specific sample apps for testing SBL boot flow on GP devices
│   │   │       ├── sbl_boot_test_&lt;board_name&gt;_allcoresTestApp_release.appimage.signed                  &lt;= SBL loadable board specific signed sample apps for testing SBL boot flow on HS-SE devices
│   │   │       ├── sbl_boot_test_&lt;board_name&gt;_allcoresTestApp_release.appimage.hs_fs                   &lt;= SBL loadable board specific signed sample apps for testing SBL boot flow on HS-FS devices
│   │   │       └── sbl_baremetal_boot_xip_test_&lt;board_name&gt;_mcu1_0TestApp_release.xer5f.bin            &lt;= Binary image that can be eXecuted In Place on XIP capable boot media
|   │   ├── [soc]
│   │   │   ├── mcuAmplinker.lds                            &lt;= Linker command file when TI CGT is used for Asym. Multiproc. boot
│   │   │   ├── mpuAmplinker.lds                            &lt;= GCC linker command file (for Cortex Axx cores) for Asym. Multiproc. boot
│   │   │   ├── mcuXiplinker.lds                            &lt;= Linker command file for XIP trampoline app
│   │   │   └── xip_entry.lds                               &lt;= Linker command file for XIP test case
|   │   ├── mcuBootPerfLinker_small.lds                     &lt;= TI CGT Linker command file for SBL performance tuning example (for boot with MCU domain only)
│   │   ├── mcu[core#]LockStepLinker.lds                    &lt;= Linker command file when TI CGT is used for R5 lock-step boot
│   │   ├── mpuSmplinker.lds                                &lt;= GCC linker command file (for Cortex Axx cores) for SMP boot
│   │   ├── xip_entry.asm                                   &lt;= Entry point of XIP trampoline app
│   │   ├── xip_stub.c                                      &lt;= Simple SBL test app that demonstrates transitioning to a XIP app
│   │   ├── sbl_amp_multicore.c                             &lt;= Simple SBL test that displays UART message
│   │   ├── sbl_amp_multicore_sections.h                    &lt;= Allows same source to be loaded to different sections for different cores.
│   │   ├── sbl_mcu_0_boot_perf_benchmark.c                 &lt;= SBL Test to tune boot performance.
│   │   ├── sbl_multicore_a53.asm                           &lt;= Test case entry point  for Cortex-Axx cores
│   │   ├── sbl_multicore_r5.asm                            &lt;= Test case entry point for Cortex-R5 cores
│   │   ├── sbl_multicore_r5_sections.inc                   &lt;= Allows same source to be loaded to different sections for different MCUs.
│   │   ├── sbl_printf.c                                    &lt;= Lightweight UART printf function for SBL testing
│   │   ├── sbl_smp_multicore.c                             &lt;= Simple SBL SMP test that uses SBL lib to reset MPUs
│   │   └── sbl_smp_r5.asm                                  &lt;= Provides dummy override function for __mpu_init for SMP testcase.
│   ├── boot_app
│   │     ├── binary
│   │     │      └── [board]
│   │     │             └── [bootmedia]
│   │     │                     ├── sbl_boot_app_&lt;bootmedia&gt;_&lt;*(hs)&gt;_&lt;board_name&gt;_mcu1_0_freertos_TestApp_relese.appimage.*           &lt;= BootApp image which boots main domain cores in stages
│   │     │                     ├── sbl_boot_app_&lt;bootmedia&gt;_linux_&lt;*(hs)&gt;_&lt;board_name&gt;_mcu1_0_freertos_TestApp_relese.appimage.*     &lt;= BootApp image which boots main domain cores and Linux on A72 core
│   │     │                     └── sbl_boot_app_&lt;bootmedia&gt;_qnx_&lt;*(hs)&gt;_&lt;board_name&gt;_mcu1_0_freertos_TestApp_relese.appimage.*       &lt;= BootApp image which boots main domain cores and QNX on A72 core
│   │     ├── boot_app_main.c
│   │     ├── boot_app_mmcsd.c
│   │     ├── boot_app_mmcsd.h
│   │     ├── boot_app_ospi.c
│   │     ├── boot_app_ospi.h
│   │     ├── boot_app_priv.h
│   │     ├── linker_r5_freertos.lds      &lt;= linker file to build BootApp
│   │     ├── r5_mpu_freertos.c           &lt;= MPU configurations for BootApp
│   │     ├── soc
│   │     │    └── [board]
│   │     │            ├── boot_core_defs.c
│   │     │            └── boot_core_defs.h
│   │     ├── scripts
│   │     │      └── generate_latepps.sh  &lt;= script to generate lateapp images which are multicore images generated from sbl boot test
│   │     └── multicore_images
│   │             └── [board]
│   │                    ├── multicore_*stage1.appimage*  &lt;= lateapp1, multicore image which boots main R5 cores in stage1
│   │                    ├── multicore_*stage2.appimage*  &lt;= lateapp2, multicore image which boots DSP cores in stage2
│   │                    └── multicore_*stage3.appimage*  &lt;= lateapp3, multicore image which boots A72 core in stage3
│   └── eeprom_test
│        ├── sbl_eeprom_test.c  &lt;= Simple baremetal application which checks whether EEPROM content is properly copied to DDR or not
│        └── makefile           &lt;= makefile to build sbl_eeprom_test
│
│
├── binary                                                        &lt;= ROM bootable SBL images for each board/boot media
│   ├── [board]
│       └── [bootmedia]
│           └── bin
│               └── sbl_[bootmedia]_img_mcu1_0_release.tiimage
│
├── lib                                                           &lt;= SBL lib for each boot media/board supported
│   ├── [bootmedia]
│   │   └── [board]
│   │       └── r5f
│   │           └── release
│   │               └── sbl_lib_[bootmedia].aer5f
│   └── cust
│       └── [board]
│           └── r5f
│               └── release
│                   └── sbl_lib_cust.aer5f
│
├── soc                                 &lt;= SOC specific SBL code
│   └── k3
│       ├── [soc]
|       |   └── linker.cmd              &lt;= Linker file used for generating ROM loadable SBL image.
│       ├── sbl_err_trap.h              &lt;= Error loops for SBL
│       ├── sbl_init.asm                &lt;= SBL Entry point
│       ├── sbl_misc.asm                &lt;= SBL Assembly utility functions
│       ├── sbl_log.h                   &lt;= SBL logging framework
│       ├── sbl_sci_client.c            &lt;= Calls system firmware on DMSC
│       ├── sbl_sci_client.h
│       ├── sbl_slave_core_boot.c       &lt;= Code that contains the sequence to release a core from reset
│       ├── sbl_slave_core_boot.h
│       ├── sbl_soc.c                   &lt;= Cache Ops, PMU init, image verfication, etc &amp; SoC specific code like RAT Init..
│       ├── sbl_soc_cfg.h               &lt;= Abstraction layer for hiding SoC level changes from SBL
│       └── sbl_profile.h               &lt;= SBL profiling framework
│
├── src                                 &lt;= Common drivers used across SOCs
│   ├── mmcsd
│   ├── emmc
│   ├── hyperflash
│   ├── ospi
│   ├── qspi
│   ├── uart
│   ├── rprc                            &lt;= RPRC image parser used by SBL
│   └── spi
│
└── tools
    ├── btoccs
    ├── byteswap
    ├── ccsutil
    ├── combined_appimage               &lt;= Creates a &quot;combined_*&quot; .appimage file for booting HLOS images (e.g., ATF,U-boot,Linux)
    │   ├── bin
    │   │   └── [board]
    │   │       ├── base-board.dtb          &lt;= Default (example) Linux DTB per platform - to be replaced with desired DTB
    │   │       ├── bl31.bin                &lt;= Checked-in ATF image from LCPD installers of latest release
    │   │       ├── bl32.bin                &lt;= Checked-in OPTEE image from LCPD installers of latest release
    │   │       ├── Image                   &lt;= Checked-in Kernel image from LCPD installers of latest release
    │   │       ├── u-boot.img              &lt;= Checked-in u-boot image from LCPD installers of latest release
    │   │       ├── u-boot-spl.bin          &lt;= Checked-in A72 SPL image from LCPD installers of latest release
    │   │       ├── combined_opt.appimage   &lt;= Checked-in image which boots Linux from SBL
    │   │       └── combined_dev.appimage   &lt;= Checked-in image which boots U-Boot from SBL
    │   ├── config.mk                       &lt;= Configuration make include file. Use this to specify images to include in combined.appimage
    │   └── makefile                        &lt;= combined_*.appimage Makefile
    ├── BootApp_binaries
    │   ├── linux                           &lt;= These images are used to boot Linux from BootApp
    │   │   └── [board]
    │   │       ├── atf_optee.appimage            &lt;= Checked-in ATF OPTEE appimage
    │   │       ├── tidtb_linux.appimage          &lt;= Checked-in dtb appimage
    │   │       └── tikernelimage_linux.appimage  &lt;= Checked-in Linux kernel appimage
    │   └── qnx                            &lt;= These images are used to boot QNX from BootApp
    │       └── [board]
    │            ├── atf_optee.appimage    &lt;= Checked-in ATF OPTEE appimage
    │            └── ifs_qnx.appimage      &lt;= Checked-in QNX appimage
    │
    ├── multicoreImageGen                 &lt;= Stitches multiple RPRC images for different cores into a single image
    ├── out2rprc                          &lt;= Converts .out into .rprc files, so that SBL can load non-continuous memory sections
    ├── scripts                           &lt;= Scripts used by .out  generated by CCS projects into SBL loadable images
    │   ├── K3ImageGen.bat
    │   └── K3ImageGen.sh
    └── tiImageGen                        &lt;= Unused for AM65xx/J721E. Image generation is handled by PDK build framework (&lt;sdk_install_path&gt;/pdk_*/packages/ti/build/)
</pre></div>
</div>
</section>
<section id="image-formats-1">
<span id="image-formats"></span><h2><span class="section-number">5.2.5. </span>Image Formats<a class="headerlink" href="#image-formats-1" title="Permalink to this headline">¶</a></h2>
<p><strong>SBL format:</strong></p>
<p>To generate a bootable image, the SBL build uses the x509CertificateGen script to
sign the sbl binary with so that the ROM Boot Loader (RBL) can parse it. The image
format expected by the RBL has been described in detail in the Image Format Section
of the <a class="reference external" href="http://www.ti.com/lit/pdf/spruil1">J721E Technical Reference Manual</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For HS devices, the SBL and system firmware have to be signed with the MPK.
Processor SDK sign SBL and system firmware with a TI Dummy Key on HS device.
Use sbl_&lt;bootmode&gt;_img to boot on GP devices and sbl_&lt;bootmode&gt;_img_hs to boot on HS devices.
The build system invokes the script
&lt;PDK&gt;/packages/ti/build/makerules/x509CertificateGen* which inturn calls OpenSSL
to create the X509 certificate.</p>
</aside>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For compatibility, all signed certificates must include a software
revision extension <strong>with a minimum value of 1</strong> as ROM will use this
to enforce the revision programmed into the device efuses for
anti-rollback protection. This default value of 1 is set into the SDK
scripts but must be incremented during the lifecycle of the device if
or when the efuse value is incremented. See
<a class="reference external" href="http://software-dl.ti.com/tisci/esd/latest/6_topic_user_guides/otp_revision.html">http://software-dl.ti.com/tisci/esd/latest/6_topic_user_guides/otp_revision.html</a>
for more details.</p>
</aside>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the combined ROM boot image, SBL and system firmware are embedded in a boot
image with a single x509 certificate. ROM utilizes the x509 extension ext_boot_info
to support this format. The components of this format has been described in detail in
the Image Format Section of the <a class="reference external" href="http://www.ti.com/lit/pdf/spruil1">J721E Technical Reference Manual</a></p>
</aside>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The TI Dummy Key(s) <em>MUST</em> be replaced by customers during production
with their own Private Keys. If the TI Dummy Keys are used in a production
system, the system will be open to security attacks. The path of the default
(dummy) key used by the signing script for HS devices is
&lt;PDK&gt;/packages/ti/build/makerules/k3_dev_mpk.pem</p>
</aside>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While SBL and system firmware images signed with the TI Dummy Keys will work
on both GP and HS devices, the boot time will be significantly impacted on GP
devices. Using SBL signed by TI Dummy Keys on GP devices is only recommended
during the prototyping phase - when porting code developed on GP to HS devices.</p>
</aside>
<p><strong>Application image format:</strong></p>
<p>Two utilities - out2rprc and multicoreImageGen are used to convert an application elf
image(s) into an image loadable by the SBL. The structure of a multicore application
image is provided below:</p>
<img alt="../_images/multicore_image_format.png" src="../_images/multicore_image_format.png" />
<img alt="../_images/rprc_file_format.png" src="../_images/rprc_file_format.png" />
<p><strong>RPRC File Header Format</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Magic String(43525052)</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Entry Point (Location)</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Number of Sections</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000010</p></td>
<td><p><strong>Version</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>RPRC Section Header Format</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Load Address</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Size</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000010</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Multicore boot image format</strong></p>
<p><strong>Meta Header Start</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Magic String (0x5254534D)</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Number of Files</strong></p></td>
</tr>
<tr class="row-even"><td><p>0x00000008</p></td>
<td><p><strong>Device ID</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x0000000C</p></td>
<td><p><strong>App Image Version</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Meta Header per Core</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Core ID</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Image Offset</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Meta Header Core End</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset</p></th>
<th class="head"><p>Binary value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x00000000</p></td>
<td><p><strong>Reserved</strong></p></td>
</tr>
<tr class="row-odd"><td><p>0x00000004</p></td>
<td><p><strong>Magic String End (0x444E454D)</strong></p></td>
</tr>
</tbody>
</table>
<p><strong>Signed application image format:</strong></p>
<p>To convert the multicore application image into a format that can be verified,  the build flow uses
the x509CertificateGen script to create a x509 certificate for the app image. Images that have a
x509 certificate are called signed images. Signed applications images are mandatory for HS devices,
but will work also work on GP devices.</p>
<p>Signed images are automatically detected by the SBL and loaded into a scratch memory area specified during
SBL build. The scratch memory area used by default is specified in <a class="reference external" href="https://git.ti.com/keystone-rtos/sbl/blobs/master/build/sbl_lib.mk">sbl_lib.mk</a> via the flags SBL_SCRATCH_MEM_START and
SBL_SCRATCH_MEM_SIZE. The SBL_SCRATCH_MEM* options can also be specified for custom builds to override
the defaults.</p>
<p>The SBL scratch memory is unavailable to applications during app load time, as the SBL is
still active. Once the SBL transfers control to the application, this memory is available for app
use - in other words SBL_SCRATCH_MEM* is available during app runtime.</p>
<p>For information on the application’s X.509 certificate format, please refer
<a class="reference external" href="http://downloads.ti.com/tisci/esd/latest/2_tisci_msgs/security/sec_cert_format.html#security-x509-certificate-documentation">Security X509 Certificate Documentation</a></p>
</section>
<section id="building-the-sbl-and-its-components">
<h2><span class="section-number">5.2.6. </span>Building the SBL and its components<a class="headerlink" href="#building-the-sbl-and-its-components" title="Permalink to this headline">¶</a></h2>
<p>This section will cover compiling SBL for GP and HS devices.
It will also show how to compile a loadable appimage file from an example application,
which can be used as a reference to compile your own custom application.</p>
<section id="pre-requisites-to-building">
<h3><span class="section-number">5.2.6.1. </span>Pre-requisites to Building<a class="headerlink" href="#pre-requisites-to-building" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Set your environment using pdksetupenv.bat or pdksetupenv.sh located in &lt;PDK&gt;/packages directory. Refer to
<a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#setup-environment">Processor SDK RTOS Building</a> for information on setting up your build environment</p></li>
</ul>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>SBL needs openssl to build. To check if openssl is present, type the
following at the linux or windows prompt.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">openssl</span><span class="w"> </span><span class="n">version</span>
</pre></div>
</div>
<ul class="simple">
<li><p>To build on Linux, you need to have <a class="reference external" href="http://www.mono-project.com">mono</a> installed.</p></li>
<li><p>Refer <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/Overview.html#command">Build Dependencies</a> for instructions on how to install these tools,
if they are not already present on your system.</p></li>
</ul>
</div></section>
<section id="compiling-sbl-for-gp-general-purpose-device">
<h3><span class="section-number">5.2.6.2. </span>Compiling SBL for GP (General Purpose) Device<a class="headerlink" href="#compiling-sbl-for-gp-general-purpose-device" title="Permalink to this headline">¶</a></h3>
<p><strong>Compiling the SBL</strong></p>
<p>To build all the SBL components:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">build</span>
<span class="n">gmake</span><span class="w"> </span><span class="n">clean</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="n">windows</span><span class="p">)</span>
<span class="n">make</span><span class="w"> </span><span class="n">clean</span><span class="w"> </span><span class="n">all</span><span class="w">  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="n">Linux</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>SBL image files are be located at: <strong>&lt;PDK&gt;/packages/ti/boot/sbl/binary/</strong></p></li>
<li><p>SBL examples are located at <strong>&lt;PDK&gt;/packages/ti/boot/sbl/examples/k3MulticoreApp/binary</strong></p></li>
<li><p>SBL lib are located at <strong>&lt;PDK&gt;/packages/ti/boot/sbl/lib/</strong></p></li>
</ul>
<p><strong>Compile time options for the SBL</strong></p>
<p>The SBL supports several compile time options to tweak the SBL to satisfy requirements of
ease of use, boot time and size. These can be enabled or disabled by editing <a class="reference external" href="http://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/boot/sbl/sbl_component.mk">sbl/sbl_component.mk</a></p>
<ul class="simple">
<li><p>SBL_LOG_LEVEL : Controls amount of SBL logs (on the MCU UART) and system firmware logs(on WAKEUP UART).
Varies from 0(no logs) to  3 (all logs)</p></li>
<li><p>SBL_USE_DMA : Valid values are 0 (use CPU to access boot media) or 1 (use DMA to
access boot media).</p></li>
<li><p>SBL_DISPLAY_PROFILE_INFO : At the end of the boot process, displays a log of timestamps
at which different SBL profile points are hit. This is useful to see how much
time the SBL spends in different functions. SBL_LOG_LEVEL can significantly
affect performance numbers.</p></li>
<li><p>SBL_ENABLE_PLL : Dials up all the PLLs calling Board_init(). Makes it easier for
applications as they no longer have to initialize the PLLs. However, enabling this
significantly increases boot time and power consumption. Requires system firmware to
be loaded.</p></li>
<li><p>SBL_ENABLE_CLOCKS : Enables all the module clocks by calling Board_init(). Makes
it easier for applications as they no longer have to enable clocks.</p></li>
<li><p>SBL_ENABLE_DDR : Initializes the DDR. At the cost of boot time, this enables
applications to run from and use DDR. SBL_ENABLE_CLOCKS and SBL_ENABLE_PLL must
also be enabed for this to work. Enabling this option increases the boot time.</p></li>
<li><p>SBL_SKIP_MCU_RESET : Jumps to the MCU0 application entry point
without resetting the core. Enables faster boot time. Will not change the MCU’s
mode (lock-step/split). Application also inherits the MCU state as the SBL
left it in.</p></li>
<li><p>SBL_ENABLE_DEV_GRP_MCU : Will cause the system firmware to only use MCU domain
resources during system firmware initialization. This can be done either to support
boot when the main power domain is off, or to save boot time.</p></li>
<li><p>SBL_ENABLE_HLOS_BOOT: SBL will take some extra steps to prepare certain peripherals
and resources to be handed over for HLOS (e.g., Linux) control from the Cortex-A
cores.</p></li>
<li><p>SBL_HLOS_OWNS_FLASH : Ensures the SBL will leave the OSPI flash in single SPI mode,
so that the MAIN domain Cortex-A code (e.g., HLOS) can reset the flash and take
control of it, if needed.</p></li>
<li><p>SBL_SKIP_PINMUX_ENABLE : SBL will skip any PINMUX init being done in the bootloader
and expect that it will be handled by a subsequent application.</p></li>
<li><p>SBL_SKIP_LATE_INIT : SBL will skip calling the SoC Late Init functions,
normally contained in SBL_SocLateInit()</p></li>
<li><p>SBL_USE_MCU_DOMAIN_ONLY : SBL will configure &amp; boot MCU domain cores ONLY. Saves
boot time when configuring &amp; using MCU domain only (especially when testing
MCU-only boot or measuring Early CAN response).</p></li>
</ul>
<p>The SBL also supports a “custom” build, in addition to standard out-of-box builds.
A custom build is a useful way of testing out the effect of different build options -
like when optimizing for boot time, or enabling custom usecases like eXecute In Place (XIP)
to reduce memory usage.</p>
<p>For an example of how to use such custom builds, please refer to <a class="reference external" href="https://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/boot/sbl/sbl_component.mk#n1177">sbl/sbl_component.mk</a>. It shows
how to specify a select list of build options while building SBL images and libs.</p>
<p><strong>ROM Combined Image boot</strong></p>
<p>Certain devices (J7200, J721S2, and J784S4) support a combined boot image flow. In this flow,
a boot binary blob has both Secondary bootloader (SBL) and System Firmware (SYS-FW) embedded in the boot image with a single X509 certificate.
ROM employs a new X509 extension called ext_boot_info. It supports multiple boot components with a single certificate as described in the
“Extended Boot Info Extension” of the <a class="reference external" href="http://www.ti.com/lit/pdf/spruil1">J721E Technical Reference Manual</a> and below:</p>
<img alt="../_images/combined_rom_image_format.png" src="../_images/combined_rom_image_format.png" />
<p>To create the combined boot image, simply build an alternate SBL bootloader
target with “_combined” (GP device) or “_combined_hs” (HS device) appended to the build target name
(only for MMCSD or OSPI boot modes).</p>
<p>SBL Build Target Examples for ROM Combined image boot:</p>
<ul class="simple">
<li><p>GP device : To boot from SD card, use the “sbl_mmcsd_img_combined” build target. For OSPI boot mode, use “sbl_ospi_img_combined”.</p></li>
<li><p>HS device : To boot from SD card, use the “sbl_mmcsd_img_combined_hs” build target. For OSPI boot mode, use “sbl_ospi_img_combined_hs”.</p></li>
</ul>
<p>Note :</p>
<ul class="simple">
<li><p>To create the combined board configurations utilized in the boot image, use make target “sciclient_boardcfg_combined”</p></li>
<li><p>The combined boot image flow defaults to using the J7200 ES2.0 TIFS version for J7200 HS variants</p></li>
<li><p>ROM does not support the combined boot image flow for J721E</p></li>
<li><p>For HS-SE non prime devices, an additional component in ext_boot_info (SYS-FW Inner certificate) is added to the boot image</p></li>
</ul>
<p><strong>HLOS boot</strong></p>
<p>The SBL now also supports booting ARM Trusted Firmware (ATF) along with either U-boot
or HLOS images (e.g., Linux + DTB) on the Cortex-A cores of the device, when used together
with the “combined_appimage” make facility in the SBL tools dir.</p>
<p>To boot the combined.appimage that is produced, simply build an alternate SBL bootloader
target with “_hlos” (GP device) or “_hlos_hs” (HS device) appended to the build target name
(only for MMCSD or OSPI boot modes).</p>
<p>SBL Build Target Examples for HLOS Boot:</p>
<ul class="simple">
<li><p>GP device : To boot from SD card, use the “sbl_mmcsd_img_hlos” build target. For OSPI boot mode, use “sbl_ospi_img_hlos”.</p></li>
<li><p>HS device : To boot from SD card, use the “sbl_mmcsd_img_hlos_hs” build target. For OSPI boot mode, use “sbl_ospi_img_hlos_hs”.</p></li>
</ul>
<p>Note :</p>
<ul class="simple">
<li><p>base-board.dtb needs to be modified to ensure that SD card filesystem (‘rootfs’) is specified for the Linux filesystem in each case.</p></li>
<li><p>For J721E SBL initializes the SERDES and hence the same should be disabled in device tree.</p></li>
<li><p>To disable serdes : Add ‘status = “disabled”;’ for serdes0, serdes1, serdes2</p></li>
</ul>
<p><strong>SBL Startup</strong></p>
<p>The SBL can specify the R5 configuration (lockstep or split) that ROM needs to use when it
starts up the SBL. This info is passed to ROM as a field in the X509 certificate. The value
in this field can be controlled by editing the build flag R5_STARTUP_MODE  in <a class="reference external" href="https://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/boot/sbl/build/sbl_img.mk#n170">sbl/build/sbl_img.mk</a></p>
<ul class="simple">
<li><p>EFUSE_DEFAULT : SBL will run with the same R5 configuration the boot rom ran in.</p></li>
<li><p>SPLIT_MODE  : ROM will switch the R5 to split mode before starting the SBL (default).</p></li>
</ul>
<p><strong>Enabling/Disabling JTAG on secure devices</strong></p>
<p>JTAG access is controlled using a field in the X509 certificate.</p>
<p>By default, for an easy out of box experience, the Processor SDK enables debug via JTAG
on High Secure devices. Leaving JTAG enabled, while making it easy for software development,
creates a major security hole in production devices.</p>
<p>To disable/change the level of JTAG access on HS devices, update the value of the debugType field in the
signing scripts <a class="reference external" href="http://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/build/makerules/x509template.txt#n74">build/makerules/x509template.txt</a>
(when building from windows) and <a class="reference external" href="http://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/build/makerules/x509CertificateGen.sh#n513">build/makerules/x509CertificateGen.sh</a> (when building from linux).</p>
<p>Valid values are:</p>
<ul class="simple">
<li><p>0 : Disable all JTAG access (most secure and most restrictive)</p></li>
<li><p>1 : Use device defaults (most secure and most restrictive)</p></li>
<li><p>2 : Allow debug of non-secure code, when the CPU is running in secure mode, JTAG connectivity will be lost</p></li>
<li><p>4 : Allow debug of both secure and non-secure code (least secure and least restrictive). This is the default.</p></li>
</ul>
<p><strong>Copying EEPROM Content</strong></p>
<ul class="simple">
<li><p>SBL copies EEPROM content to DDR</p></li>
<li><p>By default SBL copies to 0x90000000, user can also specifies to which address
EEPROM content should be copied by passing EEPROM_DATA_DDR_ADDRESS=&lt;address&gt; while building SBL</p></li>
</ul>
</section>
<section id="compiling-sbl-for-hs-high-security-device">
<span id="compiling-apps-for-sbl"></span><h3><span class="section-number">5.2.6.3. </span>Compiling SBL for HS (High Security) Device<a class="headerlink" href="#compiling-sbl-for-hs-high-security-device" title="Permalink to this headline">¶</a></h3>
<p>This section should be skipped if you are using a GP device.</p>
<p><strong>Compile Non-encrypted SBL for HS Device</strong></p>
<p>The steps to build HS SBL and HS Uniflash Programmer are as below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">build</span>
<span class="n">make</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="w"> </span><span class="n">sbl_</span><span class="o">&lt;</span><span class="n">bootmode</span><span class="o">&gt;</span><span class="n">_img_hs</span><span class="w"> </span><span class="n">BOARD</span><span class="o">=</span><span class="n">$BOARD</span>

<span class="n">where</span><span class="w"> </span><span class="n">boot</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">mmcsd</span><span class="p">,</span><span class="w"> </span><span class="n">ospi</span><span class="p">,</span><span class="w"> </span><span class="n">hyperflash</span><span class="p">,</span><span class="w"> </span><span class="n">uart</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">$BOARD</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">j721e_evm</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">listed</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="o">**</span><span class="n">make</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="w"> </span><span class="n">help</span><span class="o">**</span>
<span class="n">This</span><span class="w"> </span><span class="n">generates</span><span class="w"> </span><span class="n">HS</span><span class="w"> </span><span class="n">SBL</span><span class="w"> </span><span class="n">images</span><span class="w"> </span><span class="n">under</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">binary</span><span class="o">/&lt;</span><span class="n">$BOARD</span><span class="o">&gt;</span><span class="n">_hs</span><span class="w"> </span><span class="n">folder</span>
</pre></div>
</div>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>Make sure build environment is set up using <strong>pdksetupenv</strong> if you have not done so when compiling for GP device.</p></li>
<li><p>If the make does not succeed, try setting DISABLE_RECURSE_DEPS=no like so: <strong>make -s sbl_&lt;bootmode&gt;_img_hs BOARD=$BOARD DISABLE_RECURSE_DEPS=no</strong>.</p></li>
</ul>
</div><p>Building HS Uniflash programmer is similar to SBL. Instead provide the make target as “board_utils_uart_flash_programmer_hs”.
This generates HS uniflash programmer image under &lt;PDK&gt;/packages/ti/board/utils/uniflash/target/bin/&lt;$BOARD&gt;_hs folder</p>
<p><strong>Compile Encrypted SBL for HS Device</strong></p>
<p>A few additional steps on top of compiling non-encrypted SBL for HS device is necessary when compiling an encrypted SBL.</p>
<ol class="arabic simple">
<li><p>Open the file &lt;PDK&gt;/packages/ti/build/makerules/x509CertificateGen.sh or x509CertificateGen.ps1 if on Windows.</p></li>
<li><p>Edit line 119 of x509CertificateGen to <code class="docutils literal notranslate"><span class="pre">ENC_BIN=$BIN&quot;-ENC-&quot;$CERT_SIGN</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ENC_BIN=$CERT_SIGN&quot;-ENC-&quot;$BIN</span></code></p></li>
<li><p>Open &lt;PDK&gt;/packages/ti/build/makerules/common.mk</p></li>
<li><p>Edit line 638 of common.mk that starts with <strong>$(SBL_CERT_GEN) -b $(SBL_BIN_PATH) …</strong>
by adding the flags <strong>-e $(PDK_INSTALL_PATH)/ti/build/makerules/k3_dev_mek.txt -y ENCRYPT</strong></p></li>
<li><p>Compile encrypted SBL for HS device using the same command used for non-encrypted SBL for HS device</p></li>
</ol>
<p>This generates encrypted HS SBL images under &lt;PDK&gt;/packages/ti/boot/sbl/binary/&lt;$BOARD&gt;_hs folder with the same name as non-encrypted HS SBL image.</p>
</section>
<section id="compiling-appimage-that-can-be-loaded-by-sbl">
<h3><span class="section-number">5.2.6.4. </span>Compiling appimage that can be loaded by SBL<a class="headerlink" href="#compiling-appimage-that-can-be-loaded-by-sbl" title="Permalink to this headline">¶</a></h3>
<p>In this section we will demonstrate how you can create a SBL loadable appimage from an existing ELF file.</p>
<p><strong>Memory Map Considerations</strong></p>
<p>Applications that the SBL loads must comply generally with the <a class="reference internal" href="#sbl-memory-usage">sbl-memory-usage</a>.
In the application’s linker command file, care must be taken to not use the first
0x100 bytes of the MCU R5’s ATCM memory, as well as the SBL reserved memory from 0x41C00100
to 0x41C80000, for J7xx devices.
If the applications are signed, no loadable sections must be placed in the SBL scratch memory
area. The scratch memory can be used at application runtime for stacks, heaps, etc.</p>
<p>Also, the SCISERVER now needs to be started on MCU1_0, as part of the MCU1_0 application.
The board configuration space for SBL to leave behind for the SCISERVER in MCU SRAM should
be left as reserved, at least until Sciclient_init() has executed on MCU1_0 - it is from
0x41C80000 to 0x41C82000.  Similarly, the common header location from 0x41CFFB00 to 0x41D00000
should also be left untouched until Sciclient_init() has finished execution.</p>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>The local address 0x0 of the MPU is not accessible from the MCU, so any MPU linker
command file must not specify any loadable sections in that memory region. The SBL
will not be able to access that memory to load code or data.</p></li>
</ul>
</div><p><strong>Compile SBL loadable image from ELF executables</strong></p>
<p>Depending on the usecase, an ELF application executable can be converted into an
image that can be loaded by SBL in many ways.</p>
<ul class="simple">
<li><p><strong>Using CCS</strong>: Any project created using the pdkProjectCreate scripts will
automatically generate a SBL loadable app, as part of a post-build step.</p></li>
<li><p><strong>Using makefiles</strong>: Add the following lines to the component’s .mk file</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">app_name_SBL_APPIMAGEGEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yes</span>
<span class="k">export</span><span class="w"> </span><span class="n">app_name_SBL_APPIMAGEGEN</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Existing ELF executable</strong>: By calling the K3ImageGen script.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Linux</span><span class="w"> </span><span class="n">Syntax</span><span class="o">:</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">K3ImageGen</span><span class="p">.</span><span class="n">sh</span><span class="w"> </span><span class="o">&lt;</span><span class="n">CoreID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="p">.</span><span class="n">out</span><span class="o">&gt;</span>

<span class="nl">Example</span><span class="p">:</span>
<span class="n">cd</span><span class="w">  </span><span class="o">&lt;</span><span class="n">sdk_install_path</span><span class="o">&gt;/</span><span class="n">pdk_</span><span class="o">*/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">scripts</span><span class="o">/</span>
<span class="p">.</span><span class="o">/</span><span class="n">K3ImageGen</span><span class="p">.</span><span class="n">sh</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">sbl_baremetal_boot_test_</span><span class="o">&lt;</span><span class="n">board</span><span class="o">&gt;</span><span class="n">_mcu1_0TestApp_release</span><span class="p">.</span><span class="n">xer5f</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Windows Syntax: K3ImageGen.bat &quot;&lt;CoreID&gt; &lt;.out&gt;&quot;

Example:
cd  &lt;sdk_install_path&gt;\pdk_*\packages\ti\boot\sbl\tools\scripts\
K3ImageGen.bat &quot;4 sbl_baremetal_boot_test_&lt;board&gt;_mcu1_0TestApp_release.xer5f&quot;
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Multicore Images</strong>: Multicore images, as the name suggests, allows the SBL
to load applications for multiple cores from a single image. Creating such images
involves three steps.</p></li>
</ul>
<ol class="arabic simple">
<li><p>Generate the ELF application executables for individual cores</p></li>
<li><p>Convert the ELF executables into intermediate .rprc images</p></li>
<li><p>Combine the .rprc images of individual cores to create a single multicore image</p></li>
</ol>
<p>To covert any .out into the intermediate .rprc format, execute the following commands</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span><span class="w"> </span><span class="n">Linux</span><span class="o">:</span>
<span class="n">mono</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">out2rprc</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">out2rprc</span><span class="p">.</span><span class="n">exe</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">out</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>For Windows:
&lt;PDK&gt;\packages\ti\boot\sbl\tools\out2rprc\bin\out2rprc.exe input.out output.rprc
</pre></div>
</div>
<p>To stitch multiple .rprc images into a multicore image, execute the following command</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span><span class="w"> </span><span class="n">Linux</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">multicoreImageGen</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MulticoreImageGen</span><span class="w"> </span><span class="n">LE</span><span class="w"> </span><span class="mi">55</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">appimage</span><span class="w">  </span><span class="o">&lt;</span><span class="n">core_id_1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">core_1</span><span class="p">.</span><span class="n">rprc</span><span class="w"> </span><span class="o">&lt;</span><span class="n">core_id_2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">core_2</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span><span class="w"> </span><span class="n">Windows</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">multicoreImageGen</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">MulticoreImageGen</span><span class="p">.</span><span class="n">exe</span><span class="w"> </span><span class="n">LE</span><span class="w"> </span><span class="mi">55</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">appimage</span><span class="w">  </span><span class="o">&lt;</span><span class="n">core_id_1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">core_1</span><span class="p">.</span><span class="n">rprc</span><span class="w"> </span><span class="o">&lt;</span><span class="n">core_id_2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">core_2</span><span class="p">.</span><span class="n">rprc</span>
</pre></div>
</div>
<div
style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><p><strong>NOTE</strong></p>
<ul class="simple">
<li><p>The linux host environment needs to have <a class="reference external" href="http://www.mono-project.com">mono</a> installed.</p></li>
<li><p>The values used for the Core ID and Device ID can be found in <a class="reference external" href="https://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/boot/sbl/soc/k3/sbl_slave_core_boot.h#n51">sbl/soc/k3/
sbl_slave_core_boot.h</a></p></li>
<li><p>To simply load an ELF without executing it, use CoreID value ONLY_LOAD_ID</p></li>
<li><p>If an image for MCU_1 core is provided, the SBL will attempt to switch to
split mode.</p></li>
<li><p>If only an image for MCU_0 is provided, the SBL will not change the mode of the
MCU subsystem.</p></li>
<li><p>To enable SMP on the MPU, ie, to get multiple MPUs execute from a single binary
from the same address, use one of the following core_ids</p>
<ul>
<li><p>MPU1_SMP_ID: The same app binary runs on both cores in MPU cluster 1</p></li>
<li><p>MPU2_SMP_ID: The same app binary runs on both cores in MPU cluster 2</p></li>
<li><p>MPU_SMP_ID:  The same app binary runs all the MPUs</p></li>
</ul>
</li>
</ul>
</div><p><strong>Boot a HLOS+RTOS appimage using the combined_appimage tooling</strong></p>
<p>Creating a combined.appimage file including all images necessary to boot U-boot or HLOS
on the SoC’s Cortex-A cores, as well as booting RTOS images on the other remote cores can be
done with the following 4 steps:</p>
<ol class="arabic simple">
<li><p>Modify the sbl/tools/combined_appimage/config.mk file <strong>HLOS_BIN_PATH</strong> var to point to the desired HLOS images to be booted</p></li>
<li><p>Modify the <strong>HLOS_BOOT</strong> var in the same file to select “development” option (boots to SPL/U-boot) or “optimized” option (boots ATF/OPTEE/Linux)</p></li>
<li><p>Modify the <strong>RTOS_BIN_PATH</strong> var there to point to your RTOS binaries and then list the cores &amp; binaries to be loaded in the vars: IMG1, IMG2, …</p></li>
<li><p>Make the combined.appimage output app using the following make command:</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">make</span><span class="w"> </span><span class="n">BOARD</span><span class="o">=&lt;</span><span class="n">board</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GCC_LINUX_ARM_PATH</span><span class="o">=&lt;</span><span class="n">path</span><span class="o">&gt;</span>

<span class="nl">Example</span><span class="p">:</span>
<span class="n">cd</span><span class="w">  </span><span class="o">&lt;</span><span class="n">sdk_install_path</span><span class="o">&gt;/</span><span class="n">pdk_</span><span class="o">*/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">combined_appimage</span>
<span class="n">make</span><span class="w"> </span><span class="n">BOARD</span><span class="o">=&lt;</span><span class="n">board</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GCC_LINUX_ARM_PATH</span><span class="o">=&lt;</span><span class="n">sdk_install_path</span><span class="o">&gt;/</span><span class="n">gcc</span><span class="o">-</span><span class="n">arm</span><span class="mf">-9.2-2019.12</span><span class="o">-</span><span class="n">x86_64</span><span class="o">-</span><span class="n">aarch64</span><span class="o">-</span><span class="n">none</span><span class="o">-</span><span class="n">elf</span>
<span class="n">cd</span><span class="w"> </span><span class="n">bin</span><span class="o">/&lt;</span><span class="n">board</span><span class="o">&gt;</span>
<span class="n">ls</span><span class="w"> </span><span class="o">*</span><span class="p">.</span><span class="n">appimage</span>
</pre></div>
</div>
<p><strong>Converting ELF executables to executable binary images</strong></p>
<p>Sometimes, for extremely constrained and specialized usecases like ultra-low-latency boot
or DDR-less systems, an ELF application executable can be converted into a binary
image that can executed directly from the boot media, without loading into internal
memory.</p>
<p>As internal memory is always accessible, this mode of execution allows some otherwise
mandatory steps steps like DDR initlization or clock initialization  to be done
later or skipped altogether.</p>
<p>Working with such highly contrained systems require some special steps..</p>
<ul class="simple">
<li><p>Make sure that the boot media supports eXecuting In Place (XIP).</p></li>
<li><p>Use the custom SBL build to select the build options to build a SBL
that meets the usecase requirements.</p></li>
<li><p>In the linker command file for the application, make sure that all the data
sections, stacks, heaps and globals are in internal read/write memory</p></li>
<li><p>In the linker command file for the application, make sure that there are no
holes in the loadable sections. Such non-contiguous sections can drastically
blow up the binary image size, when compared to the ELF executable size.</p></li>
<li><p>To generate an executable binary image from the applications ELF file,
add the following lines to the component’s .mk file</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">app_name_SBL_APP_BINIMAGEGEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yes</span>
<span class="k">export</span><span class="w"> </span><span class="n">app_name_SBL_APP_BINIMAGEGEN</span>
</pre></div>
</div>
<p><strong>Compile encrypted SBL loadable image for HS device from ELF executables</strong></p>
<p>An edit to our appimage generation script is necessary to generate encrypted appimage:</p>
<ol class="arabic simple">
<li><p>Open &lt;PDK&gt;/packages/ti/boot/sbl/tools/scripts/K3ImageGen.sh for Linux or K3ImageGen.bat for Windows</p></li>
<li><p>Edit line 88 that starts with <strong>“$PDK_INSTALL_PATH/ti/build/makerules/x509…</strong> by adding the flags:
<strong>-e $PDK_INSTALL_PATH/ti/build/makerules/k3_dev_mek.txt -y ENCRYPT</strong></p></li>
</ol>
<p>Now the K3ImageGen script generates encrypted appimage instead of non-encrypted appimage.
It can still be used like so:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span><span class="w">  </span><span class="o">&lt;</span><span class="n">sdk_install_path</span><span class="o">&gt;/</span><span class="n">pdk_</span><span class="o">*/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">scripts</span>
<span class="p">.</span><span class="o">/</span><span class="n">K3ImageGen</span><span class="p">.</span><span class="n">sh</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;</span><span class="n">path_to_ELF_file</span><span class="o">&gt;/</span><span class="n">sbl_baremetal_boot_test_</span><span class="o">&lt;</span><span class="n">board</span><span class="o">&gt;</span><span class="n">_mcu1_0TestApp_release</span><span class="p">.</span><span class="n">xer5f</span>
</pre></div>
</div>
<p>The generated appimage should be in &lt;PDK&gt;/packages/ti/boot/sbl/examples/k3MulticoreApp/binary/&lt;board&gt;/ directory
which also has some ELF files that you can use to test the script.</p>
</section>
</section>
<section id="testing-the-sbl">
<h2><span class="section-number">5.2.7. </span>Testing the SBL<a class="headerlink" href="#testing-the-sbl" title="Permalink to this headline">¶</a></h2>
<p>SBL provides test applications to demonstrate booting the A53/A72 and R5 cores in
both symmetric/lock step &amp; asymmetric/split-mode and other features. The multicore
sample application prints a message on the UART for each core. The functionality
the different tests exercises are listed below.</p>
<ul class="simple">
<li><p>sbl_*_boot_test_*_all_coresTestApp_release: A single multicore boot test case
that boots each core in the SoC with a separate app. Also tests DDR loading</p></li>
<li><p>sbl_*_boot_test_*_xxxx_xTestApp_release.appimage: A simple testcase for booting
core xxxx_x (eg. MCU1_0, MPU2_0 etc.)</p></li>
<li><p>sbl_*_smp_test_*_all_coresTestApp_release.appimage: A single SMP boot test case
that boots MCUs in lock step. The MCU app then uses the SBL lib to boot all the
MPUs in SMP mode, ie, all the MPUs execute a single binary from the same address.</p></li>
<li><p>sbl_baremetal_boot_perf_*_mcu1_0TestApp_release.appimage: A single MCU1_0 test
case that can be used to measure the effect of enabling/disabling the perf.
tuning knobs in the SBL for OSPI boot. The size of the test case can be easily
modified by changing the values of .space directives in <a class="reference external" href="http://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/boot/sbl/example/k3MulticoreApp/sbl_boot_perf_r5.asm#n42">sbl/example/k3MulticoreApp/
sbl_boot_perf_r5.asm</a>
to profile for different app image sizes.</p></li>
<li><p>sbl_baremetal_boot_xip_test_*_mcu1_0TestApp_release.xer5f.bin: A testcase
demonstrating booting an XIP application from OSPI flash. Please refer to <a class="reference external" href="https://git.ti.com/cgit/processor-sdk/pdk/tree/packages/ti/boot/sbl/build/sbl_mcu0_boot_xip_test.mk">sbl/build/
sbl_mcu0_boot_xip_test.mk</a> and the related linker command file, under
sbl/example/k3MulticoreApp/j721e/mcuXiplinker.lds,
to see how to convert an existing application into an XIP application. The
sbl_*_xip_entry_*.appimage works in tandem with sbl_*xip_test_*.xer5f.bin to transition
the system from non-xip to xip boot, as the ROM, by default, does not support XIP from
boot media. After programming the sbl and syfw, to program  both sbl_*_xip_entry_*.appimage
and  sbl_*xip_test_*.xer5f.bin into OSPI flash, use the following uniflash commands</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>For Windows:
.\dslite.bat --mode processors -c COM9 -f &lt;PDK&gt;\packages\ti\boot\sbl\example\k3MulticoreApp\binary\&lt;soc&gt;\sbl_baremetal_boot_xip_entry_&lt;board&gt;_mcu1_0TestApp_release.appimage -d 3 -o 100000
.\dslite.bat --mode processors -c COM9 -f &lt;PDK&gt;\packages\ti\boot\sbl\example\k3MulticoreApp\binary\&lt;soc&gt;\sbl_baremetal_boot_xip_test_&lt;board&gt;_mcu1_0TestApp_release.xer5f.bin -d 3 -o 1C0000
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">For</span><span class="w"> </span><span class="n">Linux</span><span class="o">:</span>
<span class="n">sudo</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">dslite</span><span class="p">.</span><span class="n">sh</span><span class="w"> </span><span class="o">--</span><span class="n">mode</span><span class="w"> </span><span class="n">processors</span><span class="w"> </span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyUSB1</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">example</span><span class="o">/</span><span class="n">k3MulticoreApp</span><span class="o">/</span><span class="n">binary</span><span class="o">/&lt;</span><span class="n">soc</span><span class="o">&gt;/</span><span class="n">sbl_baremetal_boot_xip_entry_</span><span class="o">&lt;</span><span class="n">board</span><span class="o">&gt;</span><span class="n">_mcu1_0TestApp_release</span><span class="p">.</span><span class="n">appimage</span><span class="w"> </span><span class="o">-</span><span class="n">d</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="mi">100000</span>
<span class="n">sudo</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">dslite</span><span class="p">.</span><span class="n">sh</span><span class="w"> </span><span class="o">--</span><span class="n">mode</span><span class="w"> </span><span class="n">processors</span><span class="w"> </span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyUSB1</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PDK</span><span class="o">&gt;/</span><span class="n">packages</span><span class="o">/</span><span class="n">ti</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">sbl</span><span class="o">/</span><span class="n">example</span><span class="o">/</span><span class="n">k3MulticoreApp</span><span class="o">/</span><span class="n">binary</span><span class="o">/&lt;</span><span class="n">soc</span><span class="o">&gt;/</span><span class="n">sbl_baremetal_boot_xip_test_</span><span class="o">&lt;</span><span class="n">board</span><span class="o">&gt;</span><span class="n">_mcu1_0TestApp_release</span><span class="p">.</span><span class="n">xer5f</span><span class="p">.</span><span class="n">bin</span><span class="w"> </span><span class="o">-</span><span class="n">d</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="mi">1</span><span class="n">C0000</span>
</pre></div>
</div>
<p>An example test log for sbl_*_boot_test_*_all_coresTestApp_release is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SBL</span><span class="w"> </span><span class="n">Revision</span><span class="o">:</span><span class="w"> </span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="w"> </span><span class="p">(</span><span class="n">MMM</span><span class="w">  </span><span class="n">DD</span><span class="w"> </span><span class="n">YYYY</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HH</span><span class="o">:</span><span class="n">MM</span><span class="o">:</span><span class="n">SS</span><span class="p">)</span>
<span class="n">TIFS</span><span class="p">(</span><span class="n">or</span><span class="w"> </span><span class="n">SYSFW</span><span class="p">)</span><span class="w">  </span><span class="n">ver</span><span class="w"> </span><span class="n">xx</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">v20xx</span><span class="p">.</span><span class="n">xx</span><span class="w"> </span><span class="p">(</span><span class="n">xxx</span><span class="w"> </span><span class="n">xxx</span><span class="p">)</span>

<span class="n">MPU1_0</span><span class="w"> </span><span class="n">running</span>
<span class="n">MPU1_1</span><span class="w"> </span><span class="n">running</span>
<span class="n">MPU2_0</span><span class="w"> </span><span class="n">running</span>
<span class="n">MPU2_1</span><span class="w"> </span><span class="n">running</span>
<span class="n">MCU1_1</span><span class="w"> </span><span class="n">running</span>
<span class="n">MCU1_0</span><span class="w"> </span><span class="n">running</span>
<span class="n">MCU1_0</span><span class="w"> </span><span class="n">reports</span><span class="o">:</span><span class="w"> </span><span class="n">All</span><span class="w"> </span><span class="n">tests</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">passed</span>
</pre></div>
</div>
<p>An example log for sbl_*_smp_test_*_all_coresTestApp_release.appimage is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SBL</span><span class="w"> </span><span class="n">Revision</span><span class="o">:</span><span class="w"> </span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="p">.</span><span class="n">xx</span><span class="w"> </span><span class="p">(</span><span class="n">MMM</span><span class="w">  </span><span class="n">DD</span><span class="w"> </span><span class="n">YYYY</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HH</span><span class="o">:</span><span class="n">MM</span><span class="o">:</span><span class="n">SS</span><span class="p">)</span>
<span class="n">TIFS</span><span class="p">(</span><span class="n">or</span><span class="w"> </span><span class="n">SYSFW</span><span class="p">)</span><span class="w">  </span><span class="n">ver</span><span class="w"> </span><span class="n">xx</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">v20xx</span><span class="p">.</span><span class="n">xx</span><span class="w"> </span><span class="p">(</span><span class="n">xxx</span><span class="w"> </span><span class="n">xxx</span><span class="p">)</span>

<span class="n">MPU</span><span class="w"> </span><span class="n">SMP</span><span class="w"> </span><span class="n">boot</span><span class="w"> </span><span class="n">test</span>
<span class="n">Cores</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">boot</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="mh">0x801007a0</span>
<span class="n">Cores</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">boot</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">lockstep</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="mh">0x70050000</span>
<span class="n">Resetting</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">ARM</span><span class="w"> </span><span class="n">cores</span><span class="w"> </span><span class="n">now</span><span class="p">...</span>
<span class="n">No</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Cortex</span><span class="o">-</span><span class="n">A</span><span class="w"> </span><span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">running</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span>
<span class="n">No</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Cortex</span><span class="o">-</span><span class="n">A</span><span class="w"> </span><span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">running</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span>
<span class="n">No</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Cortex</span><span class="o">-</span><span class="n">R</span><span class="w"> </span><span class="n">core</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">running</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span>
<span class="n">All</span><span class="w"> </span><span class="n">tests</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">passed</span>
</pre></div>
</div>
<p>An example log for sbl_baremetal_boot_perf_*_mcu1_0TestApp_release.appimage, when the best boot time is reached is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Time elapsed since start of SBL:      8579us
fxn:boot_perf_test_main     cycles:   8579974

Attempting board config ...BOARD_INIT_PLL_MAIN ...passed
BOARD_INIT_MODULE_CLOCK_MAIN...passed
BOARD_INIT_DDR...passed

Analyzing run results ....
Boot time is now optimized....
All tests have passed

Profiling info ....
MCU @ 1000000000Hz.
cycles per usec  = 1000
fxn:                            main        line:2013079    cycle:    566224        timestamp:       566us
fxn:                            main        line: 261       cycle:    566325        timestamp:       566us
fxn:               SBL_SciClientInit        line: 461       cycle:    601168        timestamp:       601us
fxn:               SBL_SciClientInit        line: 474       cycle:    651983        timestamp:       651us
fxn:               SBL_SciClientInit        line: 489       cycle:   7464480        timestamp:      7464us
fxn:               SBL_SciClientInit        line: 505       cycle:  10628628        timestamp:     10628us
fxn:               SBL_SciClientInit        line: 510       cycle:  12529805        timestamp:     12529us
**fxn:         SBL_SciclientBoardCfgPm      line: 204       cycle:        90        timestamp:         0us
fxn:               SBL_SciClientInit        line: 515       cycle:    390529        timestamp:       390us
fxn:               SBL_SciClientInit        line: 522       cycle:    916525        timestamp:       916us
fxn:                            main        line: 345       cycle:   1554351        timestamp:      1554us
fxn:                            main        line: 355       cycle:   2821071        timestamp:      2821us
fxn:                            main        line: 372       cycle:   4353571        timestamp:      4353us
fxn:               SBL_OSPIBootImage        line: 732       cycle:   5007323        timestamp:      5007us
fxn:               SBL_OSPIBootImage        line: 739       cycle:   5148927        timestamp:      5148us
fxn:                            main        line: 412       cycle:   7894632        timestamp:      7894us
fxn:                            main        line: 439       cycle:   7894801        timestamp:      7894us

NOTE : Below numbers will be corrupted if SBL_ADD_PROFILE_POINT is added anywhere

         ------- SBL Boot Performance Info overview -------

RBL Execution time                                      : 8.052ms
SBL : SBL_SciClientInit: ReadSysfwImage                 : 0.050ms
Load/Start SYSFW                                        : 6.813ms
Sciclient_init                                          : 3.164ms
Board Config                                            : 1.901ms
PM Config                                               : 0.390ms
Security Config                                         : 0.526ms
RM Config                                               : 0.638ms
SBL: Board_init (pinmux)                                : 1.267ms
SBL: Board_init (PLL)                                   : 1.532ms
SBL: Board_init (CLOCKS)                                : 0.654ms
SBL: OSPI init                                          : 0.141ms
SBL: Parsing appimage and copy to MCU SRAM &amp; Jump to App: 2.746ms
Misc                                                    : 0.035ms
Time taken to boot CAN application from SBL main : 27.909ms
Boot Performance test has passed
</pre></div>
</div>
<p>The test log for sbl_*_xip_test_*.xer5f.bin is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MCU1_0</span><span class="w"> </span><span class="n">running</span>
</pre></div>
</div>
</section>
<section id="boot-modes">
<h2><span class="section-number">5.2.8. </span>Boot Modes<a class="headerlink" href="#boot-modes" title="Permalink to this headline">¶</a></h2>
<p>The SBL supports MMCSD, OSPI, and UART Boot modes. The different boot modes
supported for Jacinto is tabulated below.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td></td>
<td><p>MMCSD</p></td>
<td><p>eMMC</p></td>
<td><p>OSPI NOR</p></td>
<td><p>OSPI NAND</p></td>
<td><p>UART</p></td>
<td><p>PCIe</p></td>
<td><p>ETH</p></td>
<td><p>HYPERFLASH</p></td>
</tr>
<tr class="row-even"><td><p>J721E EVM</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>YES</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
<td><p>NO</p></td>
</tr>
</tbody>
</table>
<p><strong>Boot Switch Settings</strong></p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td></td>
<td><p>MMCSD</p></td>
<td><p>eMMC Boot0</p></td>
<td><p>eMMC UDA</p></td>
<td><p>UART</p></td>
<td><p>OSPI NOR</p></td>
<td><p>No Boot</p></td>
</tr>
<tr class="row-even"><td><p>J721E EVM</p></td>
<td><ul class="simple">
<li><p>SW8: 1000 0010</p></li>
<li><p>SW9: 0000 0000</p></li>
<li><p>SW3: 0XXX XXXX</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>SW8: 1000 0000</p></li>
<li><p>SW9: 0100 0000</p></li>
<li><p>SW3: 0XXX XXXX</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>SW8: 1000 0000</p></li>
<li><p>SW9: 0000 0000</p></li>
<li><p>SW3: 0XXX XXXX</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>SW8: 0000 0000</p></li>
<li><p>SW9: 0111 0000</p></li>
<li><p>SW3: 0XXX XXXX</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>SW8: 0000 0000</p></li>
<li><p>SW9: 0100 0000</p></li>
<li><p>SW3: 0XXX XXXX</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>SW8: 1000 1000</p></li>
<li><p>SW9: 0111 0000</p></li>
<li><p>SW3: 0XXX XXXX</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<section id="booting-via-sd-card">
<h3><span class="section-number">5.2.8.1. </span>Booting Via SD Card<a class="headerlink" href="#booting-via-sd-card" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Preparing the SD card.</p></li>
<li><p>Booting the testcase from SD card.</p></li>
</ol>
<p><strong>Preparing the SD card</strong></p>
<ol class="arabic simple">
<li><p>To boot the target the SD card should be bootable. Follow the steps
to <a class="reference external" href="https://software-dl.ti.com/jacinto7/esd/processor-sdk-rtos-jacinto7/07_03_00_07/exports/docs/psdk_rtos/docs/user_guide/out_of_box_j721e.html">Creating bootable SD card in
Linux</a>.</p></li>
<li><p>To update the SBL with a newer version, copy the sbl image (sbl_mmcsd_img_mcu1_0_release.tiimage) to the SD card.
Rename it to <strong>tiboot3.bin</strong></p></li>
<li><p>Copy the generated application image(*.appimage or *.appimage.signed) to the SD card. Rename it to
<strong>app</strong></p></li>
<li><p>Update the TIFS with a newer version, copy the TIFS system firmware image binary (or, for HS device, use the
encrypted TIFS system firmware binary, “tifs-hs-enc.bin”) found in &lt;PDK&gt;/packages/ti/drv/sciclient/soc/V1 to the SD card as <strong>tifs.bin</strong>.</p></li>
</ol>
<p><strong>Booting the testcase from SD card</strong></p>
<ol class="arabic simple">
<li><p>Insert SD card into the SD card slot of the board.</p></li>
<li><p>Refer to the Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruis4">J721E EVM Hardware Users Guide</a> to setup the EVM to boot from MMCSD.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle the board to boot the application from the SD card.</p></li>
<li><p>The test logs will be displayed on the MCU UART</p></li>
</ol>
</section>
<section id="booting-via-emmc-uda-partition">
<h3><span class="section-number">5.2.8.2. </span>Booting Via eMMC UDA partition<a class="headerlink" href="#booting-via-emmc-uda-partition" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ol class="arabic simple">
<li><p>Preparing eMMC.</p></li>
<li><p>Booting the testcase from eMMC.</p></li>
</ol>
<p><strong>Preparing eMMC</strong></p>
<ol class="arabic simple">
<li><p>Boot the target with the linux SDK. You can find the latest linux <a class="reference external" href="https://www.ti.com/tool/download/PROCESSOR-SDK-LINUX-J721E">here</a>.</p></li>
<li><p>Prepare the SD Card with Linux Images. Follow the procedure <a class="reference external" href="https://software-dl.ti.com/processor-sdk-linux/esd/AM65X/07_01_00_17/exports/docs/linux/Overview/Processor_SDK_Linux_Formatting_SD_Card.html">here</a>.</p></li>
<li><p>Copy mksdboot.sh from &lt;Linux_SDK_Install_Directory&gt;/bin to /media/$USER/rootfs/home/root</p></li>
<li><p>Change boot mode setting to SD boot mode: SW8: 1000 0010 SW9: 0000 0000</p></li>
<li><p>Boot the board</p></li>
<li><p>login as root</p></li>
<li><p>Run the mksdboot.sh script: ./mksdboot.sh –device /dev/mmcblk0</p></li>
<li><p>Run fdisk -l to check if the /dev/mmcblk0 is partitioned</p></li>
</ol>
<p><strong>Booting the testcase from eMMC</strong></p>
<ol class="arabic simple">
<li><p>To update the SBL with a newer version, copy the sbl image (sbl_emmc_uda_img_mcu1_0_release.tiimage) to /media/$USER/rootfs/home/root in the SD card.
Rename it to <strong>tiboot3.bin</strong></p></li>
<li><p>Copy the generated application image(*.appimage or *.appimage.signed) to /media/$USER/rootfs/home/root in the SD card. Rename it to
<strong>app</strong></p></li>
<li><p>Update the TIFS with a newer version, copy the TIFS system firmware image binary (or, for HS device, use the
encrypted TIFS system firmware binary, “tifs-hs-enc.bin”) found in &lt;PDK&gt;/packages/ti/drv/sciclient/soc/V* to /media/$USER/rootfs/home/root in the SD card as <strong>tifs.bin</strong>.</p></li>
<li><p>Put the SD Card back to board and boot in SD boot mode: SW8: 1000 0010 SW9: 0000 0000</p></li>
<li><p>Copy the images to eMMC partition</p>
<ul class="simple">
<li><p>mkdir eMMC</p></li>
<li><p>mount /dev/mmcblk0p1 eMMC</p></li>
<li><p>cp tiboot3.bin eMMC</p></li>
<li><p>cp tifs.bin eMMC</p></li>
<li><p>cp app eMMC</p></li>
</ul>
</li>
<li><p>Change boot mode to eMMC UDA partition and boot the board: SW8: 1000 0000 SW9: 0000 0000</p></li>
</ol>
</div></blockquote>
</section>
<section id="booting-via-emmc-boot0-partition">
<h3><span class="section-number">5.2.8.3. </span>Booting Via eMMC BOOT0 partition<a class="headerlink" href="#booting-via-emmc-boot0-partition" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ol class="arabic simple">
<li><p>Flashing images to eMMC.</p></li>
<li><p>Booting the testcase from eMMC.</p></li>
<li><p>Limitations</p></li>
</ol>
<p><strong>Flashing images to eMMC</strong></p>
<ol class="arabic">
<li><p>Create a folder named SBL in boot partition of SD card which is flashed with the linux images. You can find how to flash linux images to SD card in prepare eMMC section under Booting Via eMMC UDA partition.</p></li>
<li><p>Copy the sbl image (sbl_emmc_boot0_img_mcu1_0_release.tiimage) to the boot partition of SD card in SBL folder.</p></li>
<li><p>Copy the generated application image(*.appimage or *.appimage.signed) to the boot partition of SD card in SBL folder.</p></li>
<li><p>Copy the TIFS system firmware image binary (or, for HS device, use the encrypted TIFS system firmware binary, “tifs-hs-enc.bin”) boot partition of SD card in SBL folder.</p></li>
<li><p>Insert the SD card into the evm. Boot the evm in SD bootmode: SW8: 1000_0010 SW9: 0000_0000</p></li>
<li><p>Halt in uboot and Enter the following commands to download the images from an SD card and write them to the eMMC boot0 partition at respective addresses.</p>
<ul>
<li><p>Selecting device 0 (eMMC) and partition 1 (BOOT0)</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc dev 0 1</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Erasing 0x2000 sectors from 0x0. Each sector is of 512 Bytes</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc erase 0x0 0x2000</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Load SBL image to DDR from MMCSD</p>
<blockquote>
<div><ul class="simple">
<li><p>fatload mmc 1 ${loadaddr} SBL/sbl_emmc_boot0_img_mcu1_0_release.tiimage</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Write &lt;size_of_sbl_in_sectors&gt; to 0x0 from DDR</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc write ${loadaddr} 0x0 size_of_sbl_in_sectors</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Load tifs.bin to DDR from MMCSD</p>
<blockquote>
<div><ul class="simple">
<li><p>fatload mmc 1 ${loadaddr} SBL/tifs.bin</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Write &lt;size_of_tifs_in_sectors&gt; to 0x400 from DDR</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc write ${loadaddr} 0x400 size_of_tifs_in_sectors</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Load application image to DDR from MMCSD</p>
<blockquote>
<div><ul class="simple">
<li><p>fatload mmc 1 ${loadaddr} SBL/application_image</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Write &lt;size_of_app_in_sectors&gt; to 0x1400 from DDR</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc write ${loadaddr} 0x1400 size_of_app_in_sectors</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Enable Booting from BOOT0 partition of eMMC</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc partconf 0 1 1 1</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Selecting bus width</p>
<blockquote>
<div><ul class="simple">
<li><p>mmc bootbus 0 2 0 0</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</li>
<li><p>Note : To calculate size of an image in sectors see below example</p>
<ul class="simple">
<li><p>For example size of image = 409600 Bytes</p></li>
<li><p>eMMC sector size = 512 Bytes</p></li>
<li><p>Number of sectors = (409600/512)+1 =&gt; (0x64000/0x200)+1</p></li>
<li><p>size of image in sectors = 0x321</p></li>
</ul>
</li>
</ol>
<p><strong>Booting the testcase from eMMC</strong></p>
<ol class="arabic simple">
<li><p>Change the boot mode to eMMC boot via BOOT0 partition: SW8: 1000 0000 SW9: 0100 0000.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle the board to boot the application from the eMMC boot.</p></li>
<li><p>The test logs will be displayed on the MCU UART.</p></li>
</ol>
<p><strong>Limitations</strong></p>
<ol class="arabic simple">
<li><p>It can boot the application with the max size of 512000 bytes. If the size of application is more than that you need to pass MAX_APP_SIZE_EMMC=&lt;size_of_image&gt; while building image.</p></li>
<li><p>size_of_image can be calculated in the following manner.</p>
<ul class="simple">
<li><p>For example size of .appimage = 712000 bytes.</p></li>
<li><p>MAX_APP_SIZE_EMMC=0xADD40.</p></li>
</ul>
</li>
<li><p>Last point in Flashig images to eMMC should be mmc write ${loadaddr} 0x1400 &lt;size_of_image&gt; where size_of_image can be calculated as follows.</p>
<ul class="simple">
<li><p>For example size of .appimage = 712000 bytes.</p></li>
<li><p>eMMC sector size  = 512 bytes</p></li>
<li><p>Number of sectors = (712000/512) + 1 =&gt; (0xADD40/0x200) + 1</p></li>
<li><p>size_of_image = 0x56F</p></li>
</ul>
</li>
</ol>
</div></blockquote>
</section>
<section id="booting-via-ospi-flash">
<h3><span class="section-number">5.2.8.4. </span>Booting Via OSPI flash<a class="headerlink" href="#booting-via-ospi-flash" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Programming the OSPI flash</a></p></li>
<li><p>Flash addresses for Images</p></li>
<li><p>Booting the testcase from OSPI flash</p></li>
</ol>
<p><strong>Flash addresses for Images</strong></p>
<ol class="arabic simple">
<li><p>tiboot3.bin (SBL) is flashed to address 0x0</p></li>
<li><p>&lt;system_firmware_name&gt;.bin (TIFS or SYSFW) is flashed to address 0x80000</p></li>
<li><p>&lt;app_name&gt;.appimage (APP) is flashed to address 0x100000</p></li>
<li><p>Optional: &lt;xip_app&gt;.bin (XIP.bin) is flashed to 0x1C0000</p></li>
<li><p>OSPI PHY tuning data binary must also be flashed to the start of the last flash sector (e.g., usually a 512kB or 256kB size sector)</p></li>
</ol>
<p>Note: The file &lt;system_firmware_name&gt;.bin will be <strong>tifs.bin</strong> for a J7xx device
(for HS device, use the encrypted firmware binary, <strong>tifs-hs-enc.bin</strong>).</p>
<p><strong>Booting the testcase from OSPI flash</strong></p>
<ol class="arabic simple">
<li><p>Refer to the Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruis4">J721E EVM Hardware Users Guide</a> to setup the EVM to boot from OSPI.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle the board to boot the application from the OSPI flash.</p></li>
<li><p>The test logs will be displayed on the MCU UART</p></li>
</ol>
</section>
<section id="booting-via-uart">
<h3><span class="section-number">5.2.8.5. </span>Booting via UART<a class="headerlink" href="#booting-via-uart" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Refer to the Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruis4">J721E EVM Hardware Users Guide</a> to setup the EVM to boot from UART.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle the board, the console should show a sequence of CCC being printed</p></li>
<li><p>Choose the X-Modem interface and send the SBL that was built for UART. After the transfer is completed,
repeat the same steps for the system firmware and the application.
You will see notifications to perform these actions.</p></li>
</ol>
<p>Note: The system firmware binary will be <strong>tifs.bin</strong> for a J7xx device
(for HS device, use the encrypted firmware binary, <strong>tifs-hs-enc.bin</strong>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the system firmware binary is not present in the boot media, the boot will fail without displaying any
logs on the MCU UART. SBL enables UART logging only after successfully starting the system
firmware image. If the system firmware load fails, the RBL will eventually reset the system.</p>
</aside>
<section id="booting-via-hyperflash">
<h4><span class="section-number">5.2. </span>Booting Via Hyperflash<a class="headerlink" href="#booting-via-hyperflash" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_board.html#uniflash">Programming the Hyperflash</a></p></li>
<li><p>Booting the testcase from Hyperflashflash</p></li>
</ol>
<p><strong>Booting the testcase from Hyperflash</strong></p>
<ol class="arabic simple">
<li><p>Refer to the Boot Modes section in the <a class="reference external" href="http://www.ti.com/lit/pdf/spruis4">J721E EVM Hardware Users Guide</a> to setup the EVM to boot from Hyperflash.</p></li>
<li><p>Open a serial communication terminal like TeraTerm, MiniCom on host
PC and connect to the MCU UART console port</p></li>
<li><p>Power cycle  the board to boot the application from the Hyperflash.</p></li>
<li><p>The test logs will be displayed on the MCU UART</p></li>
</ol>
</section>
</section>
</section>
<section id="hsm-boot">
<h2><span class="section-number">5.2.9. </span>HSM Boot<a class="headerlink" href="#hsm-boot" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Not supported for this device</p></li>
</ul>
</section>
<section id="evm-setup-for-testing-sbl">
<h2><span class="section-number">5.2.10. </span>EVM Setup for testing SBL<a class="headerlink" href="#evm-setup-for-testing-sbl" title="Permalink to this headline">¶</a></h2>
<p>For information on board specific requirements like power supply, UART console port
connections refer the Hardware User guide of the respective boards.</p>
<p>The configurations needed to setup UART console through a serial terminal
application on host PC are listed in the next section.</p>
<p><strong>UART Console Setup</strong></p>
<p>PDK SBL prints messages on the UART Serial Console running on the host. Hence, a
serial terminal application (like Tera Term/HyperTerminal/minicom) should be
running on the host.</p>
<ul class="simple">
<li><p>The host serial port must be configured at 115200 baud, no parity, 1  stop bit
and no flow control.</p></li>
<li><p>Please ensure that the local echo setting for the terminal is turned  off.</p></li>
<li><p>All SBL prints are routed to the <a class="reference external" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_how_to_guides.html#uart-connection">MCU UART</a></p></li>
<li><p>To verify setup is correct, setup the EVM to boot from UART as the Primary Boot
Device (refer to <a class="reference external" href="http://www.ti.com/lit/pdf/spruis4">J721E EVM Hardware Users Guide</a> )
Power cycle the EVM, and look for the string CCCCCCC on the UART.</p></li>
</ul>
</section>
<section id="how-to-guides">
<h2><span class="section-number">5.2.11. </span>How to Guides<a class="headerlink" href="#how-to-guides" title="Permalink to this headline">¶</a></h2>
<section id="generate-multicore-appimage">
<h3><span class="section-number">5.2.11.1. </span>Generate Multicore Appimage<a class="headerlink" href="#generate-multicore-appimage" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Multicore appimage is a combination of rprc files of each core and a multicore header attached to it. Refer Image formats section mentioned above in the same page for more details.</p></li>
<li><p>Compiler generates executable which has an extension of .xer5f for R5 cores, .xa72fg for A72 cores, .xe66 for c66x cores and .xe71 for c7x cores.</p></li>
<li><p>Generate .rprc files using the executables with the below command:</p>
<ul class="simple">
<li><p>$(PDK_INSTALL_PATH)/ti/boot/sbl/tools/out2rprc/bin/out2rprc.exe $(PDK_INSTALL_PATH)/ti/binary/&lt;application_name&gt;/bin/&lt;board_name&gt;/&lt;exercutable_name&gt;.xer5f $(PDK_INSTALL_PATH)/ti/binary/&lt;application_name&gt;/bin/&lt;board_name&gt;/&lt;rprc_file_name&gt;.rprc</p></li>
</ul>
</li>
<li><p>Generate multicore image using .rprc files with the below command:</p>
<ul class="simple">
<li><p>$(PDK_INSTALL_PATH)/ti/boot/sbl/tools/multicoreImageGen/bin/MulticoreImageGen LE &lt;device_ID&gt; &lt;path to generate mulicore image&gt;multicore_image.appimage &lt;CORE_ID1&gt; &lt;rprc_file for CORE_ID1&gt; &lt;CORE_ID2&gt; &lt;rprc_file for CORE_ID2&gt; ….</p></li>
</ul>
</li>
<li><p>NOTE:</p>
<ul class="simple">
<li><p>device_ID is 55 for all jacinto devices</p></li>
<li><p>Find the CORE_ID’s in $(PDK_INSTALL_PATH)/ti/build/makerules/platform.mk file</p></li>
<li><p>Any application which is running on a core other than mcu1_0 needs to run sciserver_test_app on mcu1_0 to serve the sciclient calls</p></li>
</ul>
</li>
</ol>
</section>
<section id="sign-appimage">
<h3><span class="section-number">5.2.11.2. </span>Sign Appimage<a class="headerlink" href="#sign-appimage" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>For HS devices SBL authenticates the appimage before booting the appimage.</p></li>
<li><p>Appimage should be signed with cust mpk key to boot from HS-SE devices and singed with rom degenarate key to boot from HS-FS devices.</p></li>
<li><p>Use below command to sign the appimage to boot from HS-SE devices</p>
<ul class="simple">
<li><p>$(PDK_INSTALL_PATH)/ti/build/makerules/x509CertificateGen.sh -b $(appimage_path).&lt;appimage_name&gt;.appimage -o $(appimage_path).&lt;appimage_name&gt;.appimage.signed -c R5 -l 0x41C00100 -k $(PDK_INSTALL_PATH)/ti/build/makerules/k3_dev_mpk.pem</p></li>
</ul>
</li>
<li><p>Use below command to sign the appimage to boot from HS-FS devices</p>
<ul class="simple">
<li><p>$(PDK_INSTALL_PATH)/ti/build/makerules/x509CertificateGen.sh -b $(appimage_path).&lt;appimage_name&gt;.appimage -o $(appimage_path).&lt;appimage_name&gt;.appimage.hs_fs -c R5 -l 0x41C00100 -k $(PDK_INSTALL_PATH)/ti/build/makerules/rom_degenerateKey.pem</p></li>
</ul>
</li>
<li><p>Options while signing appimage</p>
<ul class="simple">
<li><p>-b : bin file that needs to be signed</p></li>
<li><p>-o : name of the final output file</p></li>
<li><p>-c : cert_type(target core on which image would be running)</p></li>
<li><p>-l : load address of the bin file</p></li>
<li><p>-k : signing key file with given key value</p></li>
</ul>
</li>
</ol>
</section>
<section id="boot-from-gp-device">
<h3><span class="section-number">5.2.11.3. </span>Boot from GP device<a class="headerlink" href="#boot-from-gp-device" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>To boot from GP device, three images are needed i.e</p>
<ul class="simple">
<li><p>SBL image which is signed with rom degenerate key</p></li>
<li><p>system firmware image (tifs) which is neither encrypted nor signed</p></li>
<li><p>application image (.appimage) which is not signed</p></li>
</ul>
</li>
<li><p>Build SBL image based on the boot media</p>
<ul>
<li><p>To boot from OSPI, use below command to build SBL image</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sbl_ospi_img</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>To boot from MMCSD, use below command to build SBL image</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sbl_mmcsd_img</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Use image with .tiimage extenstion to boot</p></li>
</ul>
</li>
<li><p>Use tifs.bin present in the specified folder</p>
<ul class="simple">
<li><p>For J721E, find tifs.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V1/</p></li>
<li><p>For J7200, find tifs.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V2/</p></li>
<li><p>For J721S2, find tifs.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V4/</p></li>
<li><p>For J784S4, find tifs.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V6/</p></li>
</ul>
</li>
<li><p>Build application to run. Use below command to build udma_memcpy application</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">udma_memcpy_testapp_freertos</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
<li><p>Use image with .appimage extension to boot from GP device</p></li>
</ul>
</li>
<li><p>Refer Boot from OSPI section in this page to boot form OSPI</p></li>
<li><p>Refer Boot from MMCSD section in this page to boot from MMCSD</p></li>
</ol>
</section>
<section id="boot-from-hs-se-device">
<h3><span class="section-number">5.2.11.4. </span>Boot from HS-SE device<a class="headerlink" href="#boot-from-hs-se-device" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>To boot from HS-SE device, three images are needed i.e</p>
<ul class="simple">
<li><p>SBL image which is signed with customer(dummy) MPK key</p></li>
<li><p>system firmware image (tifs) which is encrypted with TI MEK and signed with TI MPK and then again signed with customer(dummy) MPK key</p></li>
<li><p>application image (.appimage) which is signed with customer(dummy) MPK key</p></li>
</ul>
</li>
<li><p>Build SBL image based on the boot media</p>
<ul>
<li><p>To boot from OSPI, use below command to build SBL image</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sbl_ospi_img_hs</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>To boot from MMCSD, use below command to build SBL image</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sbl_mmcsd_img_hs</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Use image with .tiimage extenstion to boot</p></li>
</ul>
</li>
<li><p>Use tifs.bin present in the specified folder</p>
<ul class="simple">
<li><p>For J721E, find tifs-hs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V1/</p></li>
<li><p>For J7200, find tifs-hs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V2/</p></li>
<li><p>For J721S2, find tifs-hs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V4/</p></li>
<li><p>For J784S4, find tifs-hs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V6/</p></li>
<li><p>Note : For different revisions of sillicon if keys changed then name of tifs will get changed</p></li>
</ul>
</li>
<li><p>Build application to run. Use below command to build udma_memcpy application</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">udma_memcpy_testapp_freertos</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
<li><p>Use image with .appimage.signed extension to boot from HS-SE device</p></li>
</ul>
</li>
<li><p>Refer Boot from OSPI section in this page to boot form OSPI</p></li>
<li><p>Refer Boot from MMCSD section in this page to boot from MMCSD</p></li>
</ol>
</section>
<section id="boot-from-hs-fs-device">
<h3><span class="section-number">5.2.11.5. </span>Boot from HS-FS device<a class="headerlink" href="#boot-from-hs-fs-device" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>To boot from HS-FS device, three images are needed i.e</p>
<ul class="simple">
<li><p>SBL image which is signed with rom degenerate key</p></li>
<li><p>system firmware image (tifs) which is encrypted with TI MEK and signed with TI MPK</p></li>
<li><p>application image (.appimage) which is signed with rom degenerate key</p></li>
</ul>
</li>
<li><p>Build SBL image based on the boot media</p>
<ul>
<li><p>To boot from OSPI, use below command to build SBL image</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sbl_ospi_img</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>To boot from MMCSD, use below command to build SBL image</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">sbl_mmcsd_img</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Use image with .tiimage extenstion to boot</p></li>
</ul>
</li>
<li><p>Use tifs.bin present in the specified folder</p>
<ul class="simple">
<li><p>For J721E, find tifs-hs-fs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V1/</p></li>
<li><p>For J7200, find tifs-hs-fs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V2/</p></li>
<li><p>For J721S2, find tifs-hs-fs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V4/</p></li>
<li><p>For J784S4, find tifs-hs-fs-enc.bin at &lt;pdk install path&gt;/packages/ti/drv/sciclient/soc/V6/</p></li>
<li><p>Note : For different revisions of sillicon if keys changed then name tifs will get changed</p></li>
</ul>
</li>
<li><p>Build application to run. Use below command to build udma_memcpy application</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">udma_memcpy_testapp_freertos</span> <span class="pre">SOC=&lt;soc_name&gt;</span> <span class="pre">BOARD=&lt;board_name&gt;</span> <span class="pre">CORE=mcu1_0</span> <span class="pre">-sj</span></code></p></li>
<li><p>Use image with .appimage.hs_fs extension to boot from HS-FS device</p></li>
</ul>
</li>
<li><p>Refer Boot from OSPI section in this page to boot form OSPI</p></li>
<li><p>Refer Boot from MMCSD section in this page to boot from MMCSD</p></li>
</ol>
</section>
<section id="boot-from-ospi">
<h3><span class="section-number">5.2.11.6. </span>Boot from OSPI<a class="headerlink" href="#boot-from-ospi" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Depends on which device you are using, refer Boot from GP/HS-SE/HS-FS section present in this page to build the reqired images</p></li>
<li><p>Download uniflash tool from <a class="reference external" href="https://www.ti.com/tool/UNIFLASH">here</a></p></li>
<li><p>Change the boot mode to UART boot mode</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SW8:00000000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SW9:01110000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SW3:0XXXXXXX</span></code></p></li>
</ul>
</li>
<li><p>Flash uniflash image using the below command</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">&lt;uniflash</span> <span class="pre">install</span> <span class="pre">path&gt;/dslite.sh</span> <span class="pre">--mode</span> <span class="pre">processors</span> <span class="pre">-c</span> <span class="pre">/dev/ttyUSB*</span> <span class="pre">-f</span> <span class="pre">&lt;uniflash</span> <span class="pre">install</span> <span class="pre">path&gt;/processors/FlashWriter/&lt;board_name&gt;/uart_&lt;board_name&gt;_flash_programmer_release.tiimage</span> <span class="pre">-i</span> <span class="pre">0</span></code></p></li>
</ul>
</li>
<li><p>Flash SBL image at 0x0 using the below command</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">&lt;uniflash</span> <span class="pre">install</span> <span class="pre">path&gt;/dslite.sh</span> <span class="pre">--mode</span> <span class="pre">processors</span> <span class="pre">-c</span> <span class="pre">/dev/ttyUSB*</span> <span class="pre">-f</span> <span class="pre">&lt;pdk</span> <span class="pre">install</span> <span class="pre">path&gt;/pdk/packages/ti/boot/sbl/binary/&lt;board_name&gt;/ospi/bin/sbl_ospi_img_mcu1_0_release.tiimage</span> <span class="pre">-d</span> <span class="pre">0</span> <span class="pre">-o</span> <span class="pre">0</span></code></p></li>
</ul>
</li>
<li><p>Flash tifs.bin at 0x80000 using the below command</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">&lt;uniflash</span> <span class="pre">install</span> <span class="pre">path&gt;/dslite.sh</span> <span class="pre">--mode</span> <span class="pre">processors</span> <span class="pre">-c</span> <span class="pre">/dev/ttyUSB*</span> <span class="pre">-f</span> <span class="pre">&lt;pdk</span> <span class="pre">install</span> <span class="pre">path&gt;/pdk/packages/ti/drv/sciclient/soc/V*/tifs.bin</span> <span class="pre">-d</span> <span class="pre">0</span> <span class="pre">-o</span> <span class="pre">80000</span></code></p></li>
</ul>
</li>
<li><p>Flash application image at 0x100000 using the below command</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">&lt;uniflash</span> <span class="pre">install</span> <span class="pre">path&gt;/dslite.sh</span> <span class="pre">--mode</span> <span class="pre">processors</span> <span class="pre">-c</span> <span class="pre">/dev/ttyUSB*</span> <span class="pre">-f</span> <span class="pre">&lt;pdk</span> <span class="pre">install</span> <span class="pre">path&gt;/pdk/packages/ti/binary/udma_memcpy_testapp_freertos/bin/&lt;board_name&gt;/udma_memcpy_testapp_freertos_mcu1_0_release.appimage</span> <span class="pre">-d</span> <span class="pre">0</span> <span class="pre">-o</span> <span class="pre">100000</span></code></p></li>
</ul>
</li>
<li><p>Change boot mode to OSPI NAND and power cycle the board</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SW8:00001010</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SW9:01100000</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SW3:0XXXXXXX</span></code></p></li>
</ul>
</li>
</ol>
</section>
<section id="boot-from-mmcsd">
<h3><span class="section-number">5.2.11.7. </span>Boot from MMCSD<a class="headerlink" href="#boot-from-mmcsd" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>Depends on which device you are using, refer Boot from GP/HS-SE/HS-FS section present in this page to build the required images</p></li>
<li><p>Partition SD card to get boot and rootfs partitions. Follow the below instructions to partition SD card</p>
<ul>
<li><p>Donwnload and install the latest linux from <a class="reference external" href="https://www.ti.com/tool/download/PROCESSOR-SDK-LINUX-J721E">here</a>.</p></li>
<li><p>Run the below commands to partition the SD card</p>
<blockquote>
<div><ul class="simple">
<li><p>cd &lt;linux sdk install path&gt;/bin/</p></li>
<li><p>./mksdboot –device /dev/sd* (/dev/sd* can be /dev/sda or /dev/sdb… it represents SD card)</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</li>
<li><p>Copy SBL image as tiboot3.bin to the boot partition of SD card</p></li>
<li><p>Copy tifs.bin/tifs-hs-enc.bin/tifs-hs-fs-enc.bin as tifs.bin to the boot partition of SD card</p></li>
<li><p>Copy application image with .appimage/.appimage.signed/.appimage.hs_fs image as app to the boot partition of SD card</p></li>
</ol>
</section>
<section id="fall-back-mechanism-if-copy-failed-from-ospi-flash">
<h3><span class="section-number">5.2.11.8. </span>Fall back mechanism if copy failed from OSPI flash<a class="headerlink" href="#fall-back-mechanism-if-copy-failed-from-ospi-flash" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>This section talks about how to copy from OSPI with phy disabled if SBL fails to copy from OSPI flash when phy is enabled</p></li>
<li><p>There are two places in SBL where copy is happening from OSPI flash i.e</p>
<ul class="simple">
<li><p>Copying tifs from flash memory to SMS memory</p></li>
<li><p>Copying different sections in appimage from flash memory to differnt memories based on the application</p></li>
</ul>
<p><strong>Copying tifs from flash memory to SMS memory</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>For J721E, SBL first copies tifs from OSPI flash to OCMC memory. And then SBL gives pointer to OCMC memory to DMSC ROM. Then DMSC ROM copies tifs to SMS memory</p></li>
<li><p>For J7200, J721S2 and J784S4, SBL directly gives pointer to flash memory. Then DMSC ROM copies tifs from flash to SMS memory</p></li>
<li><p>PHY is not enabled while copying tifs to SMS memory so fall back mechanism is not needed</p></li>
</ul>
</div></blockquote>
<p><strong>Copying application from flash memory to SOC memory</strong></p>
<blockquote>
<div><ul>
<li><p>If PHY is enabled, SBL uses Board_flashRead() API to copy from flash memory to SOC memory.</p></li>
<li><p>If Board_flashRead() API returns failure due to PHY tuning then do the following steps to continue the copying wiht PHY disabled</p>
<blockquote>
<div><ul class="simple">
<li><p>Call Board_flashClose()</p></li>
<li><p>Reconfigure ospi_cfg with desired parameters i.e .phyEnable = false, .dtrEnable=false, .funcClk=25MHz, .baudRareDiv=4</p></li>
<li><p>Call OSPI_socSetInitCfg()</p></li>
<li><p>Call Board_flashOpen()</p></li>
<li><p>Now call again Board_flashRead() : which copies from flash memory with disabled PHY</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ol>
</section>
<section id="boot-from-ospi-nand">
<h3><span class="section-number">5.2.11.9. </span>Boot from OSPI NAND<a class="headerlink" href="#boot-from-ospi-nand" title="Permalink to this headline">¶</a></h3>
</section>
<section id="secure-hsm-boot-from-ospi-nand-on-hs-se-device">
<h3><span class="section-number">5.2.11.10. </span>Secure HSM Boot from OSPI NAND on HS-SE device<a class="headerlink" href="#secure-hsm-boot-from-ospi-nand-on-hs-se-device" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Not supported for this device</p></li>
</ul>
</section>
<section id="secure-hsm-boot-from-ospi-nor-on-hs-se-device">
<h3><span class="section-number">5.2.11.11. </span>Secure HSM Boot from OSPI NOR on HS-SE device<a class="headerlink" href="#secure-hsm-boot-from-ospi-nor-on-hs-se-device" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Not supported for this device</p></li>
</ul>
</section>
<section id="secure-hsm-boot-from-mmcsd-on-hs-se-device">
<h3><span class="section-number">5.2.11.12. </span>Secure HSM Boot from MMCSD on HS-SE device<a class="headerlink" href="#secure-hsm-boot-from-mmcsd-on-hs-se-device" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Not supported for this device</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="boot_app.html" class="btn btn-neutral float-right" title="5.3. Boot App" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="boot.html" class="btn btn-neutral" title="5.1. SBL Overview" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      <a href="http://www.ti.com/corp/docs/legal/copyright.shtml">&copy; Copyright 1995-2020</a>, Texas Instruments Incorporated. All rights reserved. <br>
      <a href="http://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="http://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="http://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="http://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'09_00_01',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
        });

      var menuHeight = window.innerHeight;

      var contentOffset = $(".wy-nav-content-wrap").offset();
      var contentHeight = $(".wy-nav-content-wrap").height();
      var contentBottom = contentOffset.top + contentHeight;

      function setNavbarTop() {
          var scrollTop = $(window).scrollTop();
          var maxTop = scrollTop + menuHeight;

          // If past the header
          if (scrollTop > contentOffset.top && maxTop < contentBottom) {
            stickyTop = scrollTop - contentOffset.top;
          } else if (maxTop > contentBottom) {
            stickyTop = scrollTop - contentOffset.top - (maxTop - contentBottom);
          } else {
            stickyTop = 0;
          }

          $(".wy-nav-side").css("top", stickyTop);
      }

      $(document).ready(function() {
        setNavbarTop();
        $(window).scroll(function () {
          setNavbarTop();
        });
      });
  </script>
   

</body>
</html>